<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>데연소 · Love Glass UI (피드백 고도화)</title>
    <link rel="stylesheet" href="styles/studio_calibration.css?v=20241223-24">
<!-- MediaPipe 라이브러리 (CDN) -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
<!-- 기본 캘리브레이션 설정 모듈 -->
<script src="js/default-calibration.js?v=20241223"></script>
<!-- 캘리브레이션 모듈 -->
<script src="js/calibration.js?v=20241222"></script>
<!-- 성능 모니터링 (개발용) -->
<script src="js/performance-monitor.js?v=20241222"></script>
<!-- MediaPipe 직접 모듈 -->
<script src="js/mediapipe-direct.js?v=20241223"></script>
<!-- 카메라 분석기 모듈 -->
<script src="js/camera-analyzer.js?v=20241222-2"></script>
    <!-- 음성 입력 모듈 -->
    <script src="js/voice-input.js?v=20241222-2"></script>
    <!-- TTS 관리 모듈 -->
    <script src="js/tts-manager.js?v=20241223-2"></script>
    <!-- 팝업 관리 모듈 -->
    <script src="js/popup-manager.js?v=20241223-2"></script>
    <!-- 대화 주도권 분석 모듈 -->
    <script src="js/conversation-analyzer.js?v=20241223"></script>
    <!-- 종합 점수 계산 모듈 -->
    <script src="js/comprehensive-score-calculator.js?v=20241223"></script>
    
    <script>
    // 전역 변수들
    let lastExpressionScore = 60;
    let lastExpressionText = '중립적';
    let lastExpressionUpdate = 0;
    const EXPRESSION_UPDATE_INTERVAL = 2000; // 2초마다 업데이트
    </script>
</head>
<body>



<div id="calibration-overlay" class="calibration-overlay">
    <div class="calibration-popup">
        <div id="initial-view">
            <div class="icon">
                <img src="" alt="카메라" id="cameraIcon">
            </div>
            <h2>자세 기준 측정</h2>
            <p class="sub">정확한 측정을 위해 아래 사항을 먼저 확인해 주세요.</p>

            <ul>
                <li><span class="dot"></span><span>모니터를 <strong>정면으로 응시</strong>합니다.</span></li>
                <li><span class="dot"></span><span><strong>어깨를 곧게 펴고 올바른 자세</strong>를 유지합니다.</span></li>
                <li><span class="dot"></span><span>카메라가 꺼져 있거나 연결되지 않으면 측정이 어렵습니다.</span></li>
            </ul>

            <p class="note">
                <span>정확한 피드백 제공을 위해 <strong>카메라 기반 자세 측정</strong>이 필요합니다.</span>
            </p>

            <div class="button-group">
                <button id="skip-calibration-btn" class="btn btn-secondary">건너뛰기</button>
                <button id="start-calibration-btn" class="btn btn-primary">자세 측정 시작</button>
            </div>
        </div>
        <div id="progress-view" class="hidden">
            <div class="icon">👤</div>
            <h2>자세 측정 중</h2>
            <p id="instruction-text">카메라 정면에서 정자세를 유지해 주세요.<br>(모니터 정가운데를 주시)</p>
            <div class="progress-bar-container">
                <div id="progress-bar-fill" class="progress-bar-fill"></div>
            </div>
            <div id="countdown-text" class="countdown-text">측정 완료까지 5초...</div>
        </div>
    </div>
</div>

   <!-- 초기 안내 팝업 -->
  <div id="initial-guide-overlay" class="initial-guide-overlay">
      <div class="initial-guide-popup">
          <h3>❤️ 데이트 시작!</h3>
          <p>AI 파트너와 대화를 시작해 보세요.<br>마이크 버튼이나 텍스트 입력으로<br>자연스럽게 대화를 나누어 보세요.</p>
          <button id="close-guide-btn" class="btn">시작하기</button>
      </div>
  </div>
 
 <!-- 확인 팝업 -->
 <div id="confirm-overlay" class="confirm-overlay">
     <div class="confirm-popup">
         <h3>데이트 종료</h3>
         <p>정말로 데이트를 끝내시겠습니까?</p>
         <div class="button-group">
             <button id="cancel-end-btn" class="btn btn-secondary">아니오</button>
             <button id="confirm-end-btn" class="btn btn-primary">예</button>
         </div>
     </div>
 </div>

       <!-- 카메라 경고 메시지 (상단 바) -->
   <div id="camera-warning" class="camera-warning hidden">
     <span class="warning-icon">⚠️</span>
     <span class="warning-text">카메라 권한이 필요합니다. 피드백 분석을 위해 카메라를 허용해 주세요.</span>
     <button class="warning-close" onclick="hideCameraWarning()">×</button>
   </div>
   
   <!-- 카메라 토스트 경고 메시지 (우측 상단) -->
   <div id="camera-toast" class="camera-toast hidden">
     <span class="toast-icon">⚠️</span>
     <span class="toast-text">카메라 권한이 필요합니다</span>
     <button class="toast-close" onclick="hideCameraToast()">×</button>
   </div>
 
 <!-- 상단 헤더 -->
 <header class="top-header">
   <div class="logo">
     <div class="logo-icon">🎬</div>
     <span>데연소 스튜디오</span>
   </div>
   <div class="user-info">
     <div class="action-buttons">
       <button id="recalibrate-btn" class="action-btn">자세 다시 측정하기</button>
       <button id="end-session-btn" class="action-btn primary">데이트 끝내기</button>
     </div>
   </div>
 </header>

<div class="main-content" id="main-content">
  <!-- 카메라 경고 알림 (인라인) -->
  <div id="camera-warning-inline" class="camera-warning-inline" style="display: none;">
    <div class="camera-warning-content">
      <div class="camera-warning-icon">📹</div>
      <div class="camera-warning-text">
        <h3>카메라 인식 불안정</h3>
        <p>자세를 고정하고 피드백을 받으세요</p>
      </div>
      <button class="camera-warning-close" onclick="this.parentElement.parentElement.style.display='none'">×</button>
    </div>
  </div>

  <div id="feedbackPanel" class="feedback-panel">
      <div class="card">
        <header>
          <span>💡 AI 종합 피드백</span>
          <button id="closeBtn" class="close-btn">&times;</button>
        </header>
        <section class="body">
          <!-- 호감도 섹션 (개선된 메인) -->
          <div class="likability-section-enhanced">
            <div class="likability-header">
              <h3 class="likability-main-title">💝 호감도</h3>
              <div class="likability-subtitle">AI가 느끼는 당신의 매력</div>
            </div>
            <div class="likability-content">
              <div class="likability-circle-enhanced">
                <svg viewBox="0 0 120 120">
                  <defs>
                    <linearGradient id="likability-gradient-enhanced" x1="0%" y1="0%" x2="100%" y2="100%">
                      <stop offset="0%" stop-color="#667eea" />
                      <stop offset="50%" stop-color="#764ba2" />
                      <stop offset="100%" stop-color="#f093fb" />
                    </linearGradient>
                    <filter id="glow">
                      <fegaussianblur stdDeviation="3" result="coloredBlur"/>
                      <femerge> 
                        <femergenode in="coloredBlur"/>
                        <femergenode in="SourceGraphic"/>
                      </femerge>
                    </filter>
                  </defs>
                  <circle class="circle-bg-enhanced" cx="60" cy="60" r="50" stroke="rgba(255,255,255,0.1)" stroke-width="8" fill="none"/>
                  <circle id="likability-progress-enhanced" class="circle-progress-enhanced" cx="60" cy="60" r="50" stroke="url(#likability-gradient-enhanced)" stroke-width="8" fill="none" stroke-linecap="round" filter="url(#glow)" transform="rotate(-90 60 60)"/>
                </svg>
                <div class="likability-inner">
                  <div id="likability-score-enhanced" class="likability-score-enhanced">-<span class="score-unit">%</span></div>
                  <div class="likability-status" id="likability-status">측정 중</div>
                </div>
              </div>
              <div class="likability-factors">
                <div class="factor-item">
                  <span class="factor-icon">😊</span>
                  <span class="factor-text">표정</span>
                  <span class="factor-score" id="factor-expression">-</span>
                </div>
                <div class="factor-item">
                  <span class="factor-icon">🎵</span>
                  <span class="factor-text">음성</span>
                  <span class="factor-score" id="factor-voice">-</span>
                </div>
                <div class="factor-item">
                  <span class="factor-icon">💬</span>
                  <span class="factor-text">대화</span>
                  <span class="factor-score" id="factor-conversation">-</span>
                </div>
              </div>
            </div>
          </div>

          <!-- 대화 품질 섹션 -->
          <div class="feedback-section">
            <h3 class="section-title">💬 대화 품질</h3>
            <div class="metrics-grid">
              <div class="metric-card" onclick="showInitiativeDetails()" style="cursor: pointer;">
                <div class="metric-icon">🎭</div>
                <div class="metric-content">
                  <div class="metric-title">대화 주도권</div>
                  <div class="initiative-container">
                    <div class="initiative-labels">
                      <span class="user-label">나</span>
                      <span class="ai-label">AI</span>
                    </div>
                    <div class="initiative-bar">
                      <div id="user-initiative-bar" class="user-bar" style="width: 50%;"></div>
                      <div id="ai-initiative-bar" class="ai-bar" style="width: 50%;"></div>
                    </div>
                    <div id="initiative-status" class="initiative-status">균형적</div>
                  </div>
                </div>
              </div>
              
              <div class="metric-card" onclick="showExpressionDetails()" style="cursor: pointer;">
                <div class="metric-icon">😊</div>
                <div class="metric-content">
                  <div class="metric-title">표정</div>
                  <div id="expression-score" class="metric-value">-%</div>
                  <div id="expression-status" class="metric-status" style="font-size: 10px; color: #6b7280; margin-top: 2px;">분석 대기 중</div>
                </div>
              </div>
              
              <div class="metric-card">
                <div class="metric-icon">🗣️</div>
                <div class="metric-content">
                  <div class="metric-title">말투</div>
                  <div id="tone-score" class="metric-value">-%</div>
                </div>
              </div>
            </div>
          </div>

          <!-- 신체 언어 섹션 -->
          <div class="feedback-section">
            <h3 class="section-title">🎯 신체 언어</h3>
            <div class="metrics-grid">
              <div class="metric-card" onclick="showGazeDetails()" style="cursor: pointer;">
                <div class="metric-icon">👁️</div>
                <div class="metric-content">
                  <div class="metric-title">시선 안정성</div>
                  <div id="gaze-score" class="metric-value">-%</div>
                  <div id="gaze-status" class="metric-status" style="font-size: 10px; color: #6b7280; margin-top: 2px;">분석 대기 중</div>
                </div>
              </div>
              
              <div class="metric-card" onclick="showConcentrationDetails()" style="cursor: pointer;">
                <div class="metric-icon">🎯</div>
                <div class="metric-content">
                  <div class="metric-title">집중도</div>
                  <div id="concentration-score" class="metric-value">-%</div>
                  <div id="concentration-status" class="metric-status" style="font-size: 10px; color: #6b7280; margin-top: 2px;">분석 대기 중</div>
                </div>
              </div>
              
              <div class="metric-card" onclick="showPostureDetails()" style="cursor: pointer;">
                <div class="metric-icon">✨</div>
                <div class="metric-content">
                  <div class="metric-title">자세</div>
                  <div id="posture-score" class="metric-value">-%</div>
                  <div id="posture-status" class="metric-status" style="font-size: 10px; color: #6b7280; margin-top: 2px;">분석 대기 중</div>
                </div>
              </div>
              
              <div class="metric-card" onclick="showBlinkingDetails()" style="cursor: pointer;">
                <div class="metric-icon">😉</div>
                <div class="metric-content">
                  <div class="metric-title">깜빡임</div>
                  <div id="blinking-score" class="metric-value">-%</div>
                  <div id="blinking-status" class="metric-status" style="font-size: 10px; color: #6b7280; margin-top: 2px;">분석 대기 중</div>
                </div>
              </div>
            </div>
          </div>

          <!-- 종합 점수 섹션 -->
          <div class="total-score-section">
            <div class="total-score-card" onclick="showComprehensiveScoreDetails()" style="cursor: pointer;">
              <div class="total-score-icon">🏆</div>
              <div class="total-score-content">
                <div class="total-score-title">종합 점수</div>
                <div id="total-score" class="total-score-value">-%</div>
                <div class="total-score-subtitle">시각 55% + 청각 38% + 대화 7%</div>
              </div>
            </div>
          </div>
          
          <!-- AI 피드백 섹션 -->
          <div id="ai-feedback-summary" class="ai-feedback-section">
            <div class="ai-feedback-header">
              <span class="ai-feedback-icon">🍯</span>
              <span class="ai-feedback-title">실시간 꿀팁!</span>
            </div>
            <ol class="ai-feedback-list">
                <li>상대방의 말에 긍정적으로 반응해보세요.</li>
                <li>대화가 끊기지 않게 질문을 던져보세요.</li>
                <li>자신감 있는 목소리로 말하는 것을 잊지 마세요!</li>
            </ol>
          </div>
        </section>
      </div>
    </div>

    <!-- 깜빡임 상세 정보 팝업 -->
    <div id="blinking-details-popup" class="details-popup">
      <div class="details-popup-content">
        <div class="details-popup-header">
          <h3>😉 깜빡임 분석 상세</h3>
          <button class="details-popup-close" onclick="closeBlinkingDetails()">×</button>
        </div>
        <div class="details-popup-body">
          <div class="blinking-summary">
            <div class="blinking-main">
              <div class="blinking-label">깜빡임 상태</div>
              <div id="blinking-main-value" class="blinking-main-value">-</div>
            </div>
            <div class="blinking-rate">
              <div class="blinking-label">깜빡임 빈도</div>
              <div id="blinking-rate-value" class="blinking-rate-value">-</div>
            </div>
          </div>
          <div class="blinking-breakdown">
            <div class="blinking-label">분석 요소</div>
            <div id="blinking-factors" class="blinking-factors">
              <!-- 동적으로 생성됨 -->
            </div>
          </div>
          <div class="blinking-criteria">
            <div class="blinking-label">평가 기준</div>
            <div id="blinking-criteria-text" class="blinking-criteria-text">
              깜빡임 분석 데이터가 없습니다.
            </div>
          </div>
          <div class="blinking-explanation">
            <div class="blinking-label">점수 계산 근거</div>
            <div id="blinking-explanation-text" class="blinking-explanation-text">
              깜빡임 분석 데이터가 없습니다.
            </div>
          </div>
        </div>
      </div>
    </div>

    <button id="feedbackToggleBtn" class="feedback-toggle-btn">피드백</button>

    <!-- 대화 주도권 상세 정보 팝업 -->
    <div id="initiative-details-popup" class="details-popup">
      <div class="details-popup-content">
        <div class="details-popup-header">
          <h3>🎭 대화 주도권 분석 상세</h3>
          <button class="details-popup-close" onclick="closeInitiativeDetails()">×</button>
        </div>
        <div class="details-popup-body">
          <div class="initiative-summary">
            <div class="initiative-main">
              <div class="initiative-label">주도권 점수</div>
              <div id="initiative-main-value" class="initiative-main-value">50%</div>
            </div>
            <div class="initiative-status">
              <div class="initiative-label">상태</div>
              <div id="initiative-status-text" class="initiative-status-text">균형적</div>
            </div>
          </div>
          <div class="initiative-visual">
            <div class="initiative-label">주도권 분배</div>
            <div class="initiative-bar-large">
              <div id="initiative-user-bar-large" class="user-bar-large" style="width: 50%;">
                <span class="bar-label">나</span>
              </div>
              <div id="initiative-ai-bar-large" class="ai-bar-large" style="width: 50%;">
                <span class="bar-label">AI</span>
              </div>
            </div>
          </div>
          <div class="initiative-breakdown">
            <div class="initiative-label">상세 통계</div>
            <div class="stats-grid">
              <div class="stat-item">
                <div class="stat-label">메시지 수</div>
                <div class="stat-value">
                  <span id="user-message-count" class="user-stat">0</span> : 
                  <span id="ai-message-count" class="ai-stat">0</span>
                </div>
              </div>
              <div class="stat-item">
                <div class="stat-label">메시지 길이</div>
                <div class="stat-value">
                  <span id="user-length" class="user-stat">0</span> : 
                  <span id="ai-length" class="ai-stat">0</span>
                </div>
              </div>
              <div class="stat-item">
                <div class="stat-label">질문 수</div>
                <div class="stat-value">
                  <span id="user-questions" class="user-stat">0</span> : 
                  <span id="ai-questions" class="ai-stat">0</span>
                </div>
              </div>
            </div>
          </div>
          <div class="initiative-criteria">
            <div class="initiative-label">평가 기준</div>
            <div class="criteria-list">
              <div class="criteria-item">
                <span class="criteria-weight">30%</span>
                <span class="criteria-text">메시지 수 비율</span>
              </div>
              <div class="criteria-item">
                <span class="criteria-weight">25%</span>
                <span class="criteria-text">메시지 길이 비율</span>
              </div>
              <div class="criteria-item">
                <span class="criteria-weight">25%</span>
                <span class="criteria-text">질문 비율</span>
              </div>
              <div class="criteria-item">
                <span class="criteria-weight">20%</span>
                <span class="criteria-text">대화 시작 패턴</span>
              </div>
            </div>
          </div>
          <div class="initiative-explanation">
            <div class="initiative-label">주도권 해석</div>
            <div id="initiative-explanation-text" class="initiative-explanation-text">
              대화 주도권은 메시지 수, 길이, 질문 빈도 등을 종합적으로 분석하여 계산됩니다.
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- 종합 점수 상세 정보 팝업 -->
    <div id="comprehensive-score-details-popup" class="details-popup">
      <div class="details-popup-content">
        <div class="details-popup-header">
          <h3>🏆 종합 점수 분석</h3>
          <button class="details-popup-close" onclick="closeComprehensiveScoreDetails()">×</button>
        </div>
        <div class="details-popup-body">
          <div class="main-metric-container">
            <div class="main-metric-icon">🏆</div>
            <div class="main-metric-value" id="comprehensive-main-value">0%</div>
            <div class="main-metric-label">종합 점수</div>
            <div class="main-metric-status" id="comprehensive-status-text">분석 대기 중</div>
          </div>
          
          <div class="tabs-container">
            <div class="tabs">
              <button class="tab-btn active" onclick="showComprehensiveTab('breakdown')">점수 분석</button>
              <button class="tab-btn" onclick="showComprehensiveTab('criteria')">평가 기준</button>
              <button class="tab-btn" onclick="showComprehensiveTab('explanation')">상세 설명</button>
            </div>
          </div>
          
          <div class="tab-content">
            <div id="comprehensive-breakdown-tab" class="tab-pane active">
              <div class="comprehensive-breakdown">
            <div class="comprehensive-label">카테고리별 점수</div>
            <div class="category-scores">
              <div class="category-item visual">
                <div class="category-header">
                  <span class="category-icon">👁️</span>
                  <span class="category-name">시각적 요소</span>
                  <span class="category-weight">55%</span>
                </div>
                <div class="category-score">
                  <div id="visual-average" class="category-average">0%</div>
                  <div class="category-contribution">기여도: <span id="visual-contribution">0%</span></div>
                </div>
                <div class="category-details">
                  <div class="detail-item">
                    <span class="detail-label">표정</span>
                    <span id="visual-expression" class="detail-value">0%</span>
                  </div>
                  <div class="detail-item">
                    <span class="detail-label">시선 안정성</span>
                    <span id="visual-gaze" class="detail-value">0%</span>
                  </div>
                  <div class="detail-item">
                    <span class="detail-label">자세</span>
                    <span id="visual-posture" class="detail-value">0%</span>
                  </div>
                  <div class="detail-item">
                    <span class="detail-label">깜빡임</span>
                    <span id="visual-blinking" class="detail-value">0%</span>
                  </div>
                </div>
              </div>
              <div class="category-item auditory">
                <div class="category-header">
                  <span class="category-icon">🎵</span>
                  <span class="category-name">청각적 요소</span>
                  <span class="category-weight">38%</span>
                </div>
                <div class="category-score">
                  <div id="auditory-average" class="category-average">0%</div>
                  <div class="category-contribution">기여도: <span id="auditory-contribution">0%</span></div>
                </div>
                <div class="category-details">
                  <div class="detail-item">
                    <span class="detail-label">음성 톤</span>
                    <span id="auditory-tone" class="detail-value">0%</span>
                  </div>
                  <div class="detail-item">
                    <span class="detail-label">집중도</span>
                    <span id="auditory-concentration" class="detail-value">0%</span>
                  </div>
                </div>
              </div>
              <div class="category-item conversation">
                <div class="category-header">
                  <span class="category-icon">💬</span>
                  <span class="category-name">대화 요소</span>
                  <span class="category-weight">7%</span>
                </div>
                <div class="category-score">
                  <div id="conversation-score" class="category-average">0%</div>
                  <div class="category-contribution">기여도: <span id="conversation-contribution">0%</span></div>
                </div>
                <div class="category-details">
                  <div class="detail-item">
                    <span class="detail-label">대화 주도권</span>
                    <span id="conversation-initiative" class="detail-value">0%</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="comprehensive-explanation">
            <div class="comprehensive-label">점수 해석</div>
            <div id="comprehensive-explanation-text" class="comprehensive-explanation-text">
              종합 점수는 시각적, 청각적, 대화 요소를 가중 평균하여 계산됩니다.
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- 표정 상세 정보 팝업 -->
    <div id="expression-details-popup" class="details-popup">
      <div class="details-popup-content">
        <div class="details-popup-header">
          <h3>😊 표정 분석 상세</h3>
          <button class="details-popup-close" onclick="closeExpressionDetails()">×</button>
        </div>
        <div class="details-popup-body">
          <div class="expression-summary">
            <div class="expression-main">
              <div class="expression-label">주요 표정</div>
              <div id="expression-main-value" class="expression-main-value">-</div>
            </div>
            <div class="expression-confidence">
              <div class="expression-label">신뢰도</div>
              <div id="expression-confidence-value" class="expression-confidence-value">-%</div>
            </div>
          </div>
          <div class="expression-breakdown">
            <div class="expression-label">표정별 확률</div>
            <div id="expression-probabilities" class="expression-probabilities">
              <!-- 동적으로 생성됨 -->
            </div>
          </div>
          <div class="expression-explanation">
            <div class="expression-label">점수 계산 근거</div>
            <div id="expression-explanation-text" class="expression-explanation-text">
              표정 분석 데이터가 없습니다.
            </div>
          </div>
        </div>
          </div>
  </div>

    <!-- 시선 안정성 상세 정보 팝업 -->
    <div id="gaze-details-popup" class="details-popup">
      <div class="details-popup-content">
        <div class="details-popup-header">
          <h3>👁️ 시선 안정성 분석 상세</h3>
          <button class="details-popup-close" onclick="closeGazeDetails()">×</button>
        </div>
        <div class="details-popup-body">
          <div class="gaze-summary">
            <div class="gaze-main">
              <div class="gaze-label">시선 상태</div>
              <div id="gaze-main-value" class="gaze-main-value">-</div>
            </div>
            <div class="gaze-stability">
              <div class="gaze-label">안정성 점수</div>
              <div id="gaze-stability-value" class="gaze-stability-value">-%</div>
            </div>
          </div>
          <div class="gaze-breakdown">
            <div class="gaze-label">랜드마크 정보</div>
            <div id="gaze-landmarks" class="gaze-landmarks">
              <!-- 동적으로 생성됨 -->
            </div>
          </div>
          <div class="gaze-criteria">
            <div class="gaze-label">평가 기준</div>
            <div id="gaze-criteria-text" class="gaze-criteria-text">
              시선 분석 데이터가 없습니다.
            </div>
          </div>
          <div class="gaze-explanation">
            <div class="gaze-label">점수 계산 근거</div>
            <div id="gaze-explanation-text" class="gaze-explanation-text">
              시선 분석 데이터가 없습니다.
            </div>
          </div>
        </div>
          </div>
  </div>

    <!-- 집중도 상세 정보 팝업 -->
    <div id="concentration-details-popup" class="details-popup">
      <div class="details-popup-content">
        <div class="details-popup-header">
          <h3>🎯 집중도 분석 상세</h3>
          <button class="details-popup-close" onclick="closeConcentrationDetails()">×</button>
        </div>
        <div class="details-popup-body">
          <div class="concentration-summary">
            <div class="concentration-main">
              <div class="concentration-label">집중 상태</div>
              <div id="concentration-main-value" class="concentration-main-value">-</div>
            </div>
            <div class="concentration-score">
              <div class="concentration-label">집중도 점수</div>
              <div id="concentration-score-value" class="concentration-score-value">-%</div>
            </div>
          </div>
          <div class="concentration-breakdown">
            <div class="concentration-label">분석 요소</div>
            <div id="concentration-factors" class="concentration-factors">
              <!-- 동적으로 생성됨 -->
            </div>
          </div>
          <div class="concentration-criteria">
            <div class="concentration-label">평가 기준</div>
            <div id="concentration-criteria-text" class="concentration-criteria-text">
              집중도 분석 데이터가 없습니다.
            </div>
          </div>
          <div class="concentration-explanation">
            <div class="concentration-label">점수 계산 근거</div>
            <div id="concentration-explanation-text" class="concentration-explanation-text">
              집중도 분석 데이터가 없습니다.
            </div>
          </div>
        </div>
          </div>
  </div>

    <!-- 자세 상세 정보 팝업 -->
    <div id="posture-details-popup" class="details-popup">
      <div class="details-popup-content">
        <div class="details-popup-header">
          <h3>✨ 자세 분석 상세</h3>
          <button class="details-popup-close" onclick="closePostureDetails()">×</button>
        </div>
        <div class="details-popup-body">
          <div class="posture-summary">
            <div class="posture-main">
              <div class="posture-label">자세 상태</div>
              <div id="posture-main-value" class="posture-main-value">-</div>
            </div>
            <div class="posture-score">
              <div class="posture-label">자세 점수</div>
              <div id="posture-score-value" class="posture-score-value">-%</div>
            </div>
          </div>
          <div class="posture-breakdown">
            <div class="posture-label">분석 요소</div>
            <div id="posture-factors" class="posture-factors">
              <!-- 동적으로 생성됨 -->
            </div>
          </div>
          <div class="posture-criteria">
            <div class="posture-label">평가 기준</div>
            <div id="posture-criteria-text" class="posture-criteria-text">
              자세 분석 데이터가 없습니다.
            </div>
          </div>
          <div class="posture-explanation">
            <div class="posture-label">점수 계산 근거</div>
            <div id="posture-explanation-text" class="posture-explanation-text">
              자세 분석 데이터가 없습니다.
            </div>
          </div>
        </div>
      </div>
    </div>

         <div class="card video-container">
       <header>❤️ 데이트 중</header>
               <div class="video-wrapper">
           <div id="video-loading" class="video-loading">
             <div class="loading-spinner"></div>
             <p>비디오 로딩 중...</p>
           </div>
           <video id="video" poster="https://placehold.co/1280x720/e0e8ff/ffffff?text=Video+Stream" playsinline loop></video>
        </div>
       <section class="body">
         <div class="suggestion-container">
             <h4>이런 주제로 물어보세요</h4>
             <div class="suggestion-tags">
                 <button class="tag">최근에 본 영화</button>
                 <button class="tag">주말 계획</button>
                 <button class="tag">가장 좋아하는 음식</button>
                 <button class="tag">요즘 즐겨듣는 노래</button>
             </div>
         </div>
       </section>
     </div>

     <div class="card">
       <header>💬 대화 중</header>
       <div class="chat-log" id="chatLog"></div>
                      <div class="chat-input">
           <input type="text" id="chatInput" placeholder="메시지를 입력하세요...">
           <button id="inputBtn" class="input-btn" title="메시지 전송">
                               <img src="" alt="전송" id="inputIcon">
           </button>
         </div>
    </div>
</div>

<script>
// --- 서버/엔드포인트 설정 (Vercel 프록시 사용) ---
const serverUrl = window.__API_BASE__ || "https://dys-phi.vercel.app/api/gke";
const apiEndpoints = {
  chat: `${serverUrl}/api/chat`,
  feedback: `${serverUrl}/api/feedback`,
  calibration: `${serverUrl}/api/calibration`,
  user_check: `${serverUrl}/api/user/check`,
  frame: `${serverUrl}/api/frame`,          // 프레임 업로드
  landmarks: `${serverUrl}/api/landmarks`,
};
// 개발 환경에서는 항상 WS 프로토콜 사용 (HTTP 기반)
const wsProto = "ws";

// WebSocket 설정 - 서버에서 동적으로 가져오기
let wsEndpoints = {};

async function initializeWebSocketConfig() {
  try {
    console.log('[WEBSOCKET] 서버에서 WebSocket 설정 가져오는 중...');
    const wsConfigResponse = await fetch(`${serverUrl}/api/websocket/config`);
    
    if (wsConfigResponse.ok) {
      const wsConfig = await wsConfigResponse.json();
      const wsProtocol = wsConfig.protocol || 'wss';
      const wsHost = `${wsConfig.host}:${wsConfig.port}`;
      
      wsEndpoints = {
        landmarks: `${wsProtocol}://${wsHost}/ws/landmarks`,
      };
      
      console.log('[WEBSOCKET] ✅ 서버에서 WebSocket 설정 로드 완료:', wsConfig);
      console.log('[WEBSOCKET] 사용할 WebSocket URL:', wsEndpoints.landmarks);
      return true;
    } else {
      throw new Error(`WebSocket config fetch failed: ${wsConfigResponse.status}`);
    }
  } catch (error) {
    console.warn('[WEBSOCKET] ⚠️ 서버 WebSocket 설정 로드 실패, fallback 사용:', error);
    
    // Fallback 로직
    const isGKE = location.hostname.includes('vercel.app') || location.hostname.includes('dys-phi');
    const isDev = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
    
    let wsHost, wsProtocol;
    
    if (isGKE) {
      // 프로덕션 환경 - 환경변수나 동적 설정 사용
      wsHost = window.__WS_HOST__ || '34.64.136.237'; // 환경변수로 설정 가능
      wsProtocol = 'wss';
    } else if (isDev) {
      // 개발 환경
      wsHost = location.hostname;
      wsProtocol = 'ws';
    } else {
      // 기타 환경
      wsHost = location.hostname;
      wsProtocol = location.protocol === 'https:' ? 'wss' : 'ws';
    }
    
    wsEndpoints = {
      landmarks: `${wsProtocol}://${wsHost}:8001/ws/landmarks`,
    };
    
    console.log('[WEBSOCKET] Fallback WebSocket 서버 사용:', `${wsProtocol}://${wsHost}:8001`);
    console.log('[WEBSOCKET] 환경 감지:', { isGKE, isDev, wsHost, wsProtocol });
    return false;
  }
}

// WebSocket 설정 초기화를 즉시 실행
initializeWebSocketConfig().then(success => {
  console.log('[WEBSOCKET] WebSocket 설정 초기화 완료:', success ? '서버 설정 사용' : 'Fallback 설정 사용');
}).catch(error => {
  console.error('[WEBSOCKET] WebSocket 설정 초기화 실패:', error);
});

// 전역 스코프에 노출하여 모듈에서 접근 가능하도록 설정
window.serverUrl = serverUrl;
window.wsEndpoints = wsEndpoints;
window.apiEndpoints = apiEndpoints;

// 이미지 경로 동적 설정
document.addEventListener('DOMContentLoaded', function() {
    const cameraIcon = document.getElementById('cameraIcon');
    const inputIcon = document.getElementById('inputIcon');
    
    if (cameraIcon) {
        cameraIcon.src = `${window.serverUrl}/dys_studio/img/icon/camera.webp`;
    }
    
    if (inputIcon) {
        inputIcon.src = `${window.serverUrl}/dys_studio/img/icon/enter_icon.webp`;
    }
});

// --- 랜드마크 관련 전역 변수 ---
let suggestedHz = 10; // 워커에서 사용할 FPS

// --- 보안 강화: URL 파라미터를 세션 스토리지에 저장하고 URL 정리 ---
function secureUserData() {
    // URL에서 사용자 정보 추출
const urlParams = new URLSearchParams(window.location.search);
    const userData = {
        user_id: urlParams.get('user_id'),
        email: urlParams.get('email'),
        token: urlParams.get('token'),
        persona_name: urlParams.get('persona_name'),
        persona_age: urlParams.get('persona_age'),
        persona_mbti: urlParams.get('persona_mbti'),
        persona_job: urlParams.get('persona_job'),
        persona_personality: urlParams.get('persona_personality'),
        persona_image: urlParams.get('persona_image')
    };

    // 세션 스토리지에 안전하게 저장
    sessionStorage.setItem('userData', JSON.stringify(userData));

    // URL에서 민감한 정보 제거 (히스토리 변경 없이)
    const cleanUrl = new URL(window.location.href);
    cleanUrl.search = '';
    window.history.replaceState({}, document.title, cleanUrl.pathname);
}

// --- 세션 스토리지에서 사용자 정보 가져오기 ---
function getUserData() {
    const userDataStr = sessionStorage.getItem('userData');
    if (!userDataStr) {
        console.error('사용자 정보를 찾을 수 없습니다.');
        return null;
    }
    return JSON.parse(userDataStr);
}

// --- 전역 변수로 사용자 정보 설정 ---
let userId, email, token, personaName, personaAge, personaMbti, personaJob, personaPersonality, personaImage;

// 전역 스코프에 노출하여 모듈에서 접근 가능하도록 설정
window.userId = userId;
window.email = email;
window.token = token;
window.personaName = personaName;
window.personaAge = personaAge;
window.personaMbti = personaMbti;
window.personaJob = personaJob;
window.personaPersonality = personaPersonality;
window.personaImage = personaImage;

// --- 사용자 정보 초기화 ---
function initializeUserData() {
    const userData = getUserData();
    if (userData) {
        userId = userData.user_id;
        email = userData.email;
        token = userData.token;
        personaName = userData.persona_name;
        personaAge = userData.persona_age;
        personaMbti = userData.persona_mbti;
        personaJob = userData.persona_job;
        personaPersonality = userData.persona_personality;
        personaImage = userData.persona_image;
        
        // 전역 스코프에 업데이트
        window.userId = userId;
        window.email = email;
        window.token = token;
        window.personaName = personaName;
        window.personaAge = personaAge;
        window.personaMbti = personaMbti;
        window.personaJob = personaJob;
        window.personaPersonality = personaPersonality;
        window.personaImage = personaImage;
        
        console.log('✅ 사용자 정보 초기화 완료');
        return true;
    } else {
        console.error('❌ 사용자 정보를 찾을 수 없습니다.');
        return false;
    }
}

// --- 페이지 새로고침 시 사용자 정보 복구 ---
function restoreUserDataOnRefresh() {
    // URL에 파라미터가 있으면 세션 스토리지에 저장
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has('user_id')) {
        secureUserData();
        
        // 에러 파라미터 체크 및 처리
        const error = urlParams.get('error');
        if (error) {
            handlePageError(error);
            return false; // 에러가 있으면 초기화 중단
        }
        
        // 세션 종료 성공 파라미터 체크 및 처리
        const sessionEnded = urlParams.get('session_ended');
        if (sessionEnded === 'true') {
            handleSessionEnded();
        }
        
        // 캘리브레이션 건너뛰기 파라미터 체크
        const skipCalibration = urlParams.get('skip_calibration');
        if (skipCalibration === 'true') {
            // 캘리브레이션 건너뛰기 플래그를 세션 스토리지에 저장
            sessionStorage.setItem('skipCalibration', 'true');
        }
        
        return true;
    }
    
    // URL에 파라미터가 없으면 세션 스토리지에서 복구 시도
    const userData = getUserData();
    if (userData) {
        initializeUserData();
        return true;
    }
    
    return false;
}

// --- 페이지 에러 처리 ---
function handlePageError(error) {
    console.error('❌ 페이지 에러 발생:', error);
    
    let errorMessage = '';
    let errorTitle = '';
    
    switch (error) {
        case 'session_end_failed':
            errorTitle = '세션 종료 실패';
            errorMessage = '데이트 세션을 종료하는 중 문제가 발생했습니다. 다시 시도해주세요.';
            break;
        case 'user_not_found':
            errorTitle = '사용자 정보 없음';
            errorMessage = '사용자 정보를 찾을 수 없습니다. 다시 로그인해주세요.';
            break;
        default:
            errorTitle = '오류 발생';
            errorMessage = '알 수 없는 오류가 발생했습니다. 페이지를 새로고침해주세요.';
    }
    
    // 에러 팝업 표시
    showErrorPopup(errorTitle, errorMessage);
}

// --- 에러 팝업 표시 ---
function showErrorPopup(title, message) {
    // 기존 에러 팝업이 있으면 제거
    const existingError = document.getElementById('error-popup');
    if (existingError) {
        existingError.remove();
    }
    
    // 에러 팝업 생성
    const errorPopup = document.createElement('div');
    errorPopup.id = 'error-popup';
    errorPopup.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        z-index: 5000;
        display: flex;
        justify-content: center;
        align-items: center;
    `;
    
    errorPopup.innerHTML = `
        <div style="
            background: white;
            border-radius: 16px;
            padding: 32px;
            max-width: 400px;
            width: 90%;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        ">
            <div style="
                width: 60px;
                height: 60px;
                background: #ef4444;
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                margin: 0 auto 20px;
                font-size: 24px;
                color: white;
            ">⚠️</div>
            <h3 style="margin: 0 0 16px; color: #1f2937; font-size: 20px;">${title}</h3>
            <p style="margin: 0 0 24px; color: #6b7280; line-height: 1.5;">${message}</p>
            <div style="display: flex; gap: 12px; justify-content: center;">
                <button onclick="retrySession()" style="
                    padding: 12px 24px;
                    background: #6c7cff;
                    color: white;
                    border: none;
                    border-radius: 8px;
                    font-weight: 600;
                    cursor: pointer;
                ">다시 시도</button>
                <button onclick="goToHome()" style="
                    padding: 12px 24px;
                    background: #e5e7eb;
                    color: #374151;
                    border: none;
                    border-radius: 8px;
                    font-weight: 600;
                    cursor: pointer;
                ">홈으로</button>
            </div>
        </div>
    `;
    
    document.body.appendChild(errorPopup);
}

// --- 다시 시도 함수 ---
function retrySession() {
    const errorPopup = document.getElementById('error-popup');
    if (errorPopup) {
        errorPopup.remove();
    }
    
    // 페이지 새로고침
    window.location.reload();
}

// --- 홈으로 이동 함수 ---
function goToHome() {
    // 세션 스토리지 정리
    sessionStorage.clear();
    
    // 홈페이지로 이동 (실제 홈페이지 URL로 변경 필요)
    window.location.href = '/';
}

// --- 세션 종료 성공 처리 ---
function handleSessionEnded() {
    console.log('✅ 세션이 성공적으로 종료되었습니다.');
    
    // 성공 메시지 표시
    showSuccessMessage();
    
    // URL에서 session_ended 파라미터 제거
    const url = new URL(window.location.href);
    url.searchParams.delete('session_ended');
    url.searchParams.delete('session_id');
    window.history.replaceState({}, document.title, url.toString());
}

// --- 성공 메시지 표시 ---
function showSuccessMessage() {
    // 기존 성공 메시지가 있으면 제거
    const existingSuccess = document.getElementById('success-message');
    if (existingSuccess) {
        existingSuccess.remove();
    }
    
    // 성공 메시지 생성
    const successMessage = document.createElement('div');
    successMessage.id = 'success-message';
    successMessage.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #10b981, #059669);
        color: white;
        padding: 16px 20px;
        border-radius: 12px;
        box-shadow: 0 8px 25px rgba(16, 185, 129, 0.3);
        z-index: 4000;
        display: flex;
        align-items: center;
        gap: 12px;
        animation: slideInRight 0.3s ease-out;
        max-width: 300px;
    `;
    
    successMessage.innerHTML = `
        <div style="font-size: 20px;">✅</div>
        <div>
            <div style="font-weight: 600; margin-bottom: 4px;">데이트 완료!</div>
            <div style="font-size: 14px; opacity: 0.9;">세션이 성공적으로 종료되었습니다.</div>
        </div>
        <button onclick="closeSuccessMessage()" style="
            background: none;
            border: none;
            color: white;
            font-size: 18px;
            cursor: pointer;
            opacity: 0.7;
            padding: 4px;
            border-radius: 4px;
        ">×</button>
    `;
    
    document.body.appendChild(successMessage);
    
    // 5초 후 자동으로 숨기기
    setTimeout(() => {
        closeSuccessMessage();
    }, 5000);
}

// --- 성공 메시지 닫기 ---
function closeSuccessMessage() {
    const successMessage = document.getElementById('success-message');
    if (successMessage) {
        successMessage.style.animation = 'slideOutRight 0.3s ease-out';
        setTimeout(() => {
            successMessage.remove();
        }, 300);
    }
}

// --- 애니메이션 스타일 추가 ---
const style = document.createElement('style');
style.textContent = `
    @keyframes slideInRight {
        from {
            transform: translateX(100%);
            opacity: 0;
        }
        to {
            transform: translateX(0);
            opacity: 1;
        }
    }
    
    @keyframes slideOutRight {
        from {
            transform: translateX(0);
            opacity: 1;
        }
        to {
            transform: translateX(100%);
            opacity: 0;
        }
    }
`;
document.head.appendChild(style);

// --- 모듈 로딩 유틸리티 ---
/**
 * 캘리브레이션 모듈이 로드될 때까지 대기
 * @param {number} timeout - 타임아웃 (ms)
 * @returns {Promise<void>}
 */
async function waitForCalibrationModule(timeout = 5000) {
    const startTime = Date.now();
    
    while (typeof window.CalibrationModule === 'undefined') {
        if (Date.now() - startTime > timeout) {
            console.error('[CALIBRATION] 모듈 로딩 타임아웃');
            throw new Error('캘리브레이션 모듈 로딩 실패');
        }
        // 10ms마다 체크 (non-blocking)
        await new Promise(resolve => setTimeout(resolve, 10));
    }
}

// --- 캘리브레이션 로직 (별도 파일로 분리됨) ---
document.addEventListener('DOMContentLoaded', async () => {
    // 페이지 로드 시 모든 메트릭 초기화
    setTimeout(() => {
        resetAllMetrics();
    }, 100);
    
    // 사용자 데이터 보안 처리 및 초기화
    const userDataRestored = restoreUserDataOnRefresh();
    if (!userDataRestored) {
        console.error('사용자 정보를 복구할 수 없습니다. 페이지를 다시 로드해주세요.');
        // 사용자에게 알림 표시
        alert('사용자 정보를 찾을 수 없습니다. 이전 페이지로 돌아가서 다시 시도해주세요.');
        window.history.back();
        return;
    }
    
    // 사용자 정보 초기화 (이 부분이 누락되어 있었음)
    const userDataInitialized = initializeUserData();
    if (!userDataInitialized) {
        console.error('사용자 정보 초기화에 실패했습니다.');
        alert('사용자 정보 초기화에 실패했습니다. 페이지를 새로고침해주세요.');
        window.location.reload();
        return;
    }
    
    // 캘리브레이션 모듈 로딩 대기 및 초기화
    await waitForCalibrationModule();
    console.log('[CALIBRATION] 캘리브레이션 모듈 로드 완료 - 초기화 시작');
    
    // 사용자 정보가 초기화된 후 캘리브레이션 모듈 초기화
    if (window.CalibrationModule && typeof window.CalibrationModule.initializeCalibration === 'function') {
        console.log('[CALIBRATION] 사용자 정보 초기화 완료 - 캘리브레이션 모듈 초기화 시작');
        
        // 캘리브레이션 모듈 초기화 (이벤트 리스너 설정 포함)
        if (typeof window.initializeCalibrationModule === 'function') {
            window.initializeCalibrationModule();
        }
        
        // 캘리브레이션 상태 확인 및 초기화
        window.CalibrationModule.initializeCalibration();
        
        // 캘리브레이션 모듈 초기화 완료 - 사용자 선택 대기
        console.log('[APP] 캘리브레이션 모듈 초기화 완료 - 사용자 선택 대기 중');
        // 사용자가 "건너뛰기"를 누르거나 캘리브레이션을 완료한 후에만 앱 시작됨
        
        // 앱 시작 플래그 감지
        const checkAppStart = () => {
            if (window.__readyToStartApp) {
                console.log('[APP] 사용자 선택 감지 - 앱 시작');
                initializeApp();
            } else {
                setTimeout(checkAppStart, 100); // 100ms마다 확인
            }
        };
        checkAppStart();
    } else {
        console.error('[CALIBRATION] 캘리브레이션 모듈 초기화 함수를 찾을 수 없습니다');
        // 캘리브레이션 모듈이 없어도 사용자 선택을 기다림
        console.log('[APP] 캘리브레이션 모듈 없음 - 사용자 선택 대기 중');
    }
    
    // 성능 리포트 생성 (개발 모드에서만)
    if (window.PerformanceMonitor && window.location.hostname === 'localhost') {
        window.PerformanceMonitor.generateReport();
    }
    
    // 음성 입력 관리자 초기화 (지연 실행)
    setTimeout(() => {
        if (window.VoiceInputManager) {
            window.voiceManager = new VoiceInputManager();
            console.log('[VOICE] 음성 입력 관리자 초기화 완료');
        } else {
            console.warn('[VOICE] VoiceInputManager를 찾을 수 없습니다');
        }
        
        // TTS 관리자 초기화
        if (window.TTSManager) {
            window.ttsManager = new TTSManager();
            console.log('[TTS] TTS 관리자 초기화 완료');
        } else {
            console.warn('[TTS] TTSManager를 찾을 수 없습니다');
        }
    }, 500);
});


// --- DOM 요소 가져오기 ---
const feedbackPanel = document.getElementById('feedbackPanel');
const feedbackToggleBtn = document.getElementById('feedbackToggleBtn');
const closeBtn = document.getElementById('closeBtn');
const chatLog = document.getElementById('chatLog');
const chatInput = document.getElementById('chatInput');
const inputBtn = document.getElementById('inputBtn');
const inputIcon = document.getElementById('inputIcon');

// --- 카메라 분석기 (별도 파일로 분리됨) ---
// js/camera-analyzer.js에서 CameraAnalyzer 클래스와 관련 함수들이 로드됨

// 모든 메트릭 초기화 함수
function resetAllMetrics() {
  console.log('[UI] 🔄 모든 메트릭 초기화 시작');
  
  // DOM 요소들 초기화
  const elements = {
    posture: document.getElementById('posture-score'),
    gaze: document.getElementById('gaze-score'),
    concentration: document.getElementById('concentration-score'),
    blink: document.getElementById('blinking-score'),
    expression: document.getElementById('expression-score'),
    total: document.getElementById('total-score')
  };
  
  // 점수 초기화
  Object.values(elements).forEach(element => {
    if (element) {
      element.textContent = '0%';
      element.style.color = '#6b7280'; // 회색으로 변경
    }
  });
  
  // 상태 표시 초기화
  const statusElements = {
    expression: document.getElementById('expression-status'),
    gaze: document.getElementById('gaze-status'),
    concentration: document.getElementById('concentration-status'),
    posture: document.getElementById('posture-status'),
    blinking: document.getElementById('blinking-status')
  };
  
  Object.values(statusElements).forEach(element => {
    if (element) {
      element.textContent = '분석 대기 중';
      element.style.color = '#6b7280';
    }
  });
  
  // 전역 데이터 초기화 (now managed by popup-manager.js)
  if (window.PopupManager) {
      window.PopupManager.currentExpressionData = null;
      window.PopupManager.currentGazeData = null;
      window.PopupManager.currentConcentrationData = null;
      window.PopupManager.currentPostureData = null;
      window.PopupManager.currentBlinkingData = null;
  }
  
  // 표정 분석 데이터 초기화
  lastExpressionScore = 60;
  lastExpressionText = '중립적';
  lastExpressionUpdate = 0;
  
  // 종합 점수 계산기 초기화
  if (window.ComprehensiveScoreCalculator) {
      window.ComprehensiveScoreCalculator.resetAllScores();
  }
  
  // 대화 주도권 분석기 초기화
  if (window.ConversationAnalyzer) {
      window.ConversationAnalyzer.chatHistory = [];
      window.ConversationAnalyzer.analyzeConversation();
  }
  
  console.log('[UI] ✅ 모든 메트릭 초기화 완료');
}

function updateCameraMetrics(metrics) {
  // 스로틀링: 500ms마다 한 번씩만 업데이트
  const now = Date.now();
  if (window.__lastUIUpdate__ && (now - window.__lastUIUpdate__) < 500) {
    return; // 너무 빠른 업데이트 방지
  }
  window.__lastUIUpdate__ = now;
  
  // 카메라 연결 상태 확인
  const isCameraConnected = metrics && Object.keys(metrics).length > 0;
  if (!isCameraConnected) {
    console.log('[UI] ⚠️ 카메라 데이터 없음 - UI 초기화');
    resetAllMetrics();
    return;
  }
  
  // metrics: {scores:{attention, stability, blink, posture}, labels:{expression}}
      const isWorkerMode = metrics?._isWorkerMode || false;
    const isMediaPipeDirect = metrics?._source === 'mediapipe-direct';
    const dataSource = isMediaPipeDirect ? 'MEDIAPIPE' : (isWorkerMode ? 'WORKER' : 'HTTP');
  console.log(`[UI] 🖥️ updateCameraMetrics 호출됨 (${dataSource}):`, {
    hasNeckAnalysis: !!metrics?.neckAnalysis,
    hasShoulderAnalysis: !!metrics?.shoulderAnalysis,
    hasGazeAnalysis: !!metrics?.gazeAnalysis,
    ear: metrics?.ear,
    smileIntensity: metrics?.smileIntensity,
    neckScore: metrics?.neckAnalysis?.postureScore,
    shoulderScore: metrics?.shoulderAnalysis?.shoulderPostureScore,
    gazeScore: metrics?.gazeAnalysis?.stabilityScore,
    timestamp: new Date().toISOString()
  });
  
      try {
      // DOM 요소 존재 확인
      const postureElement = document.getElementById('posture-score');
      const gazeElement = document.getElementById('gaze-score');
      const concentrationElement = document.getElementById('concentration-score');
      const blinkElement = document.getElementById('blinking-score');
      const expressionElement = document.getElementById('expression-score');
      
      console.log('[UI] 🔍 DOM 요소 확인:', {
        postureElement: !!postureElement,
        gazeElement: !!gazeElement,
        concentrationElement: !!concentrationElement,
        blinkElement: !!blinkElement,
        expressionElement: !!expressionElement
      });
      
      if (!postureElement || !gazeElement || !concentrationElement || !blinkElement || !expressionElement) {
        console.warn('[UI] ⚠️ 필요한 DOM 요소를 찾을 수 없습니다');
        return;
      }
    
    // 얼굴 인식 상태 확인 (완화)
    const cameraBlocked = metrics?.coaching_message === '카메라가 보이지 않아서 피드백을 할 수 없습니다.';
    const noFace = metrics?.status === 'no-face';
    const isFaceDetected = !(cameraBlocked || noFace);
    
    console.log('[UI] 👤 얼굴 인식 상태:', {
      cameraBlocked,
      noFace,
      isFaceDetected,
      coaching_message: metrics?.coaching_message,
      status: metrics?.status
    });
    
    if (!isFaceDetected) {
      console.log('[UI] ⚠️ 얼굴이 감지되지 않음 - UI 초기화');
      postureElement.textContent = '0%';
      gazeElement.textContent = '0%';
      concentrationElement.textContent = '0%';
      blinkElement.textContent = '0%';
      expressionElement.textContent = '0%';
      
      // 상태 표시도 초기화
      const expressionStatusElement = document.getElementById('expression-status');
      const gazeStatusElement = document.getElementById('gaze-status');
      const concentrationStatusElement = document.getElementById('concentration-status');
      
      if (expressionStatusElement) {
        expressionStatusElement.textContent = '분석 대기 중';
        expressionStatusElement.style.color = '#6b7280';
      }
      if (gazeStatusElement) {
        gazeStatusElement.textContent = '분석 대기 중';
        gazeStatusElement.style.color = '#6b7280';
      }
      if (concentrationStatusElement) {
        concentrationStatusElement.textContent = '분석 대기 중';
        concentrationStatusElement.style.color = '#6b7280';
      }
      
      // 전역 데이터도 초기화
      currentExpressionData = null;
      currentGazeData = null;
      currentConcentrationData = null;
      
      // 표정 분석 데이터 초기화
      lastExpressionScore = 60;
      lastExpressionText = '중립적';
      lastExpressionUpdate = 0;
      
      return;
    }
    
    // 자세 점수 (통일된 데이터 구조 처리)
    let postureScore = 60; // 기본값
    
    // 통일된 분석 데이터 구조 처리
    if (metrics?.neckAnalysis && metrics?.shoulderAnalysis) {
        console.log('[UI] 분석 데이터 발견:', {
            neckAnalysis: metrics.neckAnalysis,
            shoulderAnalysis: metrics.shoulderAnalysis
        });
        
        const neckScore = metrics.neckAnalysis.postureScore || 0;
        const shoulderScore = metrics.shoulderAnalysis.shoulderPostureScore || 0;
        const shoulderTilt = Math.abs(metrics.shoulderAnalysis.shoulderTilt || 0);
        const forwardHeadRatio = metrics.neckAnalysis.forwardHeadRatio || 0.05;
        
        // 통일된 자세 점수 계산 로직
        postureScore = 60; // 기본값
        
        // 어깨 기울기 페널티
        if (shoulderTilt > 20) postureScore -= 8;
        else if (shoulderTilt > 8) postureScore -= 4;
        else postureScore += 8;
        
        // 거북목 페널티
        if (forwardHeadRatio > 0.08) postureScore -= 8;
        else if (forwardHeadRatio > 0.035) postureScore -= 4;
        else postureScore += 8;
        
        // 목자세 보너스/페널티
        if (neckScore > 70) postureScore += 5;
        else if (neckScore < 40) postureScore -= 3;
        
        // 어깨자세 보너스/페널티
        if (shoulderScore > 70) postureScore += 3;
        else if (shoulderScore < 40) postureScore -= 2;
        
        // 정면 자세 보너스
        if (shoulderTilt <= 8 && forwardHeadRatio <= 0.035) postureScore += 15;
        else if (shoulderTilt <= 12 && forwardHeadRatio <= 0.05) postureScore += 10;
        else if (shoulderTilt <= 15 && forwardHeadRatio <= 0.06) postureScore += 5;
        
        console.log('[UI] 자세 점수 계산:', { neckScore, shoulderScore, shoulderTilt, forwardHeadRatio, postureScore });
    } else if (metrics?.neckScore !== undefined && metrics?.shoulderScore !== undefined) {
        // 워커 데이터 구조 (직접 점수)
        const neckScore = metrics.neckScore || 0;
        const shoulderScore = metrics.shoulderScore || 0;
        postureScore = Math.round((neckScore + shoulderScore) / 2);
        console.log('[UI] 워커 데이터 자세 점수 계산:', { neckScore, shoulderScore, postureScore });
    } else if (metrics?.neckAnalysis) {
        postureScore = metrics.neckAnalysis.postureScore || 60;
        console.log('[UI] 목 분석만 사용:', postureScore);
    } else if (metrics?.scores?.posture != null) {
        postureScore = Math.round(metrics.scores.posture);
        console.log('[UI] scores.posture 사용:', postureScore);
    } else {
        postureScore = 60;
        console.log('[UI] 분석 데이터 없음, 기본값 사용:', postureScore);
    }
    
    postureScore = Math.min(100, Math.max(0, Math.round(postureScore)));
    postureElement.textContent = `${postureScore}%`;
    
    // 종합 점수 계산기에 자세 점수 업데이트
    if (window.ComprehensiveScoreCalculator) {
      window.ComprehensiveScoreCalculator.updateVisualScore('posture', postureScore);
    }
    
    // 자세 분석 데이터 저장 (팝업용)
    if (metrics?.neckAnalysis || metrics?.shoulderAnalysis) {
      currentPostureData = {
        neckAnalysis: metrics.neckAnalysis,
        shoulderAnalysis: metrics.shoulderAnalysis,
        score: postureScore,
        timestamp: Date.now()
      };
      console.log('[UI] 자세 데이터 저장:', currentPostureData);
    } else {
      console.warn('[UI] ⚠️ 자세 분석 데이터 없음:', { 
        hasNeckAnalysis: !!metrics?.neckAnalysis,
        hasShoulderAnalysis: !!metrics?.shoulderAnalysis 
      });
    }
    
    // 자세 분석 상태 업데이트
    const postureStatusElement = document.getElementById('posture-status');
    if (postureStatusElement) {
      if (postureScore >= 80) {
        postureStatusElement.textContent = '우수';
        postureStatusElement.style.color = '#10b981';
      } else if (postureScore >= 60) {
        postureStatusElement.textContent = '양호';
        postureStatusElement.style.color = '#3b82f6';
      } else if (postureScore >= 40) {
        postureStatusElement.textContent = '보통';
        postureStatusElement.style.color = '#f59e0b';
      } else {
        postureStatusElement.textContent = '개선 필요';
        postureStatusElement.style.color = '#ef4444';
      }
    }
    
    console.log(`[UI] 💪 자세 점수 업데이트 (${dataSource}):`, { 
      rawScore: postureScore, 
      isWorkerMode,
      timestamp: new Date().toISOString()
    });
    
    if (metrics?.gazeAnalysis) {
      gazeElement.textContent = `${metrics.gazeAnalysis.stabilityScore}%`;
      
      // 종합 점수 계산기에 시선 안정성 점수 업데이트
      if (window.ComprehensiveScoreCalculator) {
        window.ComprehensiveScoreCalculator.updateVisualScore('gaze_stability', metrics.gazeAnalysis.stabilityScore);
      }
    } else if (metrics?.scores?.stability != null) {
      const stabilityScore = Math.round(metrics.scores.stability);
      gazeElement.textContent = `${stabilityScore}%`;
      
      // 종합 점수 계산기에 시선 안정성 점수 업데이트
      if (window.ComprehensiveScoreCalculator) {
        window.ComprehensiveScoreCalculator.updateVisualScore('gaze_stability', stabilityScore);
      }
    }
    
    // 집중도 점수 (통일된 데이터 구조 처리)
    let concentrationScore = 60; // 기본값
    
    if (metrics?.gazeAnalysis) {
      // 통일된 분석 데이터 구조
      const stabilityScore = metrics.gazeAnalysis.stabilityScore || 60;
      const isFocused = metrics.gazeAnalysis.isFocused || false;
      const gazeDirection = metrics.gazeAnalysis.gazeDirection || 'center';
      const jumpDistance = metrics.gazeAnalysis.jumpDistance || 0.03;
      const velocity = metrics.gazeAnalysis.velocity || 0.02;
      
      // MediaPipe 집중도 점수 계산 로직 (더 관대한 기준)
      concentrationScore = 70; // 기본값을 높임
      
      // 점프 거리 페널티 (더 관대한 기준)
      if (jumpDistance > 0.15) concentrationScore -= 30;
      else if (jumpDistance > 0.12) concentrationScore -= 20;
      else if (jumpDistance > 0.08) concentrationScore -= 15;
      else if (jumpDistance > 0.05) concentrationScore -= 10;
      else concentrationScore += 10; // 좋은 점프 거리 보너스
      
      // 속도 페널티 (더 관대한 기준)
      if (velocity > 0.1) concentrationScore -= 20;
      else if (velocity > 0.08) concentrationScore -= 15;
      else if (velocity > 0.05) concentrationScore -= 10;
      else concentrationScore += 5; // 좋은 속도 보너스
      
      // 시선 방향 보너스/페널티
      if (gazeDirection === 'center') concentrationScore += 15;
      else if (gazeDirection === 'mid') concentrationScore += 5;
      else concentrationScore -= 10;
      
      // 집중 상태 보너스
      if (isFocused) concentrationScore += 10;
      
      // 안정성 점수와 평균 계산
      concentrationScore = Math.round((concentrationScore + stabilityScore) / 2);
      
      console.log('[UI] MediaPipe 집중도 점수 계산:', { stabilityScore, isFocused, gazeDirection, jumpDistance, velocity, concentrationScore });
    } else if (metrics?.gazeScore !== undefined) {
      // 워커 데이터 구조 (직접 점수)
      concentrationScore = metrics.gazeScore || 60;
      
      console.log('[UI] 워커 데이터 집중도 점수 계산:', { gazeScore: metrics.gazeScore, concentrationScore });
    } else if (metrics?.scores?.attention != null) {
      concentrationScore = Math.round(metrics.scores.attention);
    }
    
    concentrationScore = Math.min(100, Math.max(0, Math.round(concentrationScore)));
    concentrationElement.textContent = `${concentrationScore}%`;
    updateScoreColor(concentrationElement, concentrationScore);
    
    // 종합 점수 계산기에 집중도 점수 업데이트
    if (window.ComprehensiveScoreCalculator) {
      window.ComprehensiveScoreCalculator.updateAuditoryScore('concentration', concentrationScore);
    }
    
    // 집중도 분석 데이터 저장 (팝업용)
    if (metrics?.gazeAnalysis) {
      currentConcentrationData = {
        ...metrics.gazeAnalysis,
        score: concentrationScore,
        timestamp: Date.now()
      };
      console.log('[UI] 집중도 데이터 저장:', currentConcentrationData);
    } else {
      console.warn('[UI] ⚠️ 집중도 분석 데이터(gazeAnalysis) 없음:', metrics);
    }
    
    // 집중도 분석 상태 업데이트
    const concentrationStatusElement = document.getElementById('concentration-status');
    if (concentrationStatusElement) {
      if (metrics?.gazeAnalysis) {
        const isFocused = metrics.gazeAnalysis.isFocused;
        concentrationStatusElement.textContent = isFocused ? '집중 중' : '분산됨';
        concentrationStatusElement.style.color = isFocused ? '#10b981' : '#f59e0b';
      } else {
        concentrationStatusElement.textContent = '분석 대기 중';
        concentrationStatusElement.style.color = '#6b7280';
      }
    }
    
    console.log(`[UI] 집중도 점수 업데이트 (${dataSource}):`, concentrationScore);
    
    // 시선 안정성 점수 (워커 데이터와 HTTP 분석 데이터 모두 지원)
    let gazeScore = 60; // 기본값
    
    if (metrics?.gazeAnalysis) {
      // HTTP 분석 데이터 구조
      const stabilityScore = metrics.gazeAnalysis.stabilityScore || 60;
      const jumpDistance = metrics.gazeAnalysis.jumpDistance || 0.03;
      const velocity = metrics.gazeAnalysis.velocity || 0.02;
      
      // 기존 기준: 점프 거리 40%, 속도 30%, 홍채 속도 20%, 홍채 부드러움 10%
      let jumpScore = 100;
      if (jumpDistance > 0.10) jumpScore = 0;
      else if (jumpDistance > 0.08) jumpScore = 30;
      else if (jumpDistance > 0.06) jumpScore = 60;
      else if (jumpDistance > 0.04) jumpScore = 80;
      else if (jumpDistance > 0.02) jumpScore = 90;
      
      let velocityScore = 100;
      if (velocity > 0.08) velocityScore = 0;
      else if (velocity > 0.06) velocityScore = 40;
      else if (velocity > 0.04) velocityScore = 70;
      else if (velocity > 0.02) velocityScore = 90;
      
      // 가중 평균 계산
      gazeScore = (jumpScore * 0.4) + (velocityScore * 0.3) + (stabilityScore * 0.3);
      
      console.log('[UI] HTTP 분석 시선 안정성 점수 계산:', { stabilityScore, jumpDistance, velocity, gazeScore });
    } else if (metrics?.gazeScore !== undefined) {
      // 워커 데이터 구조 (직접 점수)
      gazeScore = metrics.gazeScore || 60;
      
      console.log('[UI] 워커 데이터 시선 안정성 점수 계산:', { gazeScore: metrics.gazeScore });
    } else if (metrics?.scores?.stability != null) {
      gazeScore = Math.round(metrics.scores.stability);
    }
    
    gazeScore = Math.min(100, Math.max(0, Math.round(gazeScore)));
    gazeElement.textContent = `${gazeScore}%`;
    updateScoreColor(gazeElement, gazeScore);
    
    // 시선 분석 데이터 저장 (팝업용)
    if (metrics?.gazeAnalysis) {
      currentGazeData = {
        ...metrics.gazeAnalysis,
        score: gazeScore,
        timestamp: Date.now()
      };
      console.log('[UI] 시선 안정성 데이터 저장:', currentGazeData);
    } else {
      console.warn('[UI] ⚠️ 시선 안정성 데이터(gazeAnalysis) 없음:', metrics);
    }
    
    // 시선 분석 상태 업데이트
    const gazeStatusElement = document.getElementById('gaze-status');
    if (gazeStatusElement) {
      if (metrics?.gazeAnalysis) {
        const isFocused = metrics.gazeAnalysis.isFocused;
        gazeStatusElement.textContent = isFocused ? '집중 중' : '분산됨';
        gazeStatusElement.style.color = isFocused ? '#10b981' : '#f59e0b';
      } else {
        gazeStatusElement.textContent = '분석 대기 중';
        gazeStatusElement.style.color = '#6b7280';
      }
    }
    
    console.log(`[UI] 시선 안정성 점수 업데이트 (${dataSource}):`, gazeScore);
    
    // 깜빡임 점수 (MediaPipe earResult 기반)
    let blinkScore = 80; // 기본값
    
    if (metrics?.earResult?.blinkStatus) {
      // MediaPipe에서 받은 blinkStatus 사용
      const blinkStatus = metrics.earResult.blinkStatus;
      
      if (blinkStatus === 'closed') {
        blinkScore = 0; // 눈을 감고 있음
      } else if (blinkStatus === 'blinking') {
        blinkScore = 60; // 깜빡이는 중
      } else if (blinkStatus === 'open') {
        blinkScore = 100; // 눈을 뜨고 있음
      }
      
      console.log('[UI] MediaPipe 깜빡임 상태:', { blinkStatus, blinkScore });
    } else if (metrics?.ear !== undefined) {
      // 개인별 기준 EAR 사용 (워커에서 계산된 값)
      const ear = metrics.ear;
      const personalBaseEAR = metrics.personalBaseEAR || 0.22; // 개인별 기준
      
      // 개인 기준 대비 차이 계산 (비율로 계산)
      const earRatio = ear / personalBaseEAR;
      
      // 비율 기반 점수 계산 (더 정확한 개인별 평가)
      if (earRatio < 0.7) blinkScore = 0;      // 기준의 70% 미만 (매우 나쁨)
      else if (earRatio < 0.8) blinkScore = 30; // 기준의 80% 미만 (나쁨)
      else if (earRatio < 0.9) blinkScore = 60; // 기준의 90% 미만 (보통)
      else if (earRatio < 1.1) blinkScore = 100; // 기준의 90-110% (좋음)
      else if (earRatio < 1.2) blinkScore = 80;  // 기준의 110-120% (약간 나쁨)
      else blinkScore = 60;                       // 기준의 120% 이상 (나쁨)
    } else if (metrics?.blinkRate !== undefined) {
      // 분당 깜빡임 수 기반 (기존 기준: 6~35회/분 정상)
      if (metrics.blinkRate < 4) blinkScore = 30;
      else if (metrics.blinkRate < 6) blinkScore = 70;
      else if (metrics.blinkRate >= 6 && metrics.blinkRate <= 35) blinkScore = 100;
      else if (metrics.blinkRate <= 40) blinkScore = 70;
      else blinkScore = 55;
    } else if (metrics?.scores?.blink != null) {
      blinkScore = Math.round(metrics.scores.blink);
    } else {
      // 분석 데이터가 없을 때 기본값 사용
      blinkScore = 80;
      console.log('[UI] 깜빡임 분석 데이터 없음, 기본값 사용:', blinkScore);
    }
    
    blinkScore = Math.min(100, Math.max(0, Math.round(blinkScore)));
    blinkElement.textContent = `${blinkScore}%`;
    updateScoreColor(blinkElement, blinkScore);
    
    // 종합 점수 계산기에 깜빡임 점수 업데이트
    if (window.ComprehensiveScoreCalculator) {
      window.ComprehensiveScoreCalculator.updateVisualScore('blinking', blinkScore);
    }
    
    // 깜빡임 분석 데이터 저장 (팝업용)
    if (metrics?.earResult) {
      currentBlinkingData = {
        earResult: metrics.earResult,
        score: blinkScore,
        timestamp: Date.now()
      };
      console.log('[UI] 깜빡임 데이터 저장:', currentBlinkingData);
    } else {
      console.warn('[UI] ⚠️ earResult 데이터 없음:', metrics);
    }
    
    // 깜빡임 분석 상태 업데이트
    const blinkingStatusElement = document.getElementById('blinking-status');
    if (blinkingStatusElement) {
      if (metrics?.earResult?.blinkStatus) {
        const blinkStatus = metrics.earResult.blinkStatus;
        if (blinkStatus === 'open') {
          blinkingStatusElement.textContent = '눈 뜸';
          blinkingStatusElement.style.color = '#10b981';
        } else if (blinkStatus === 'blinking') {
          blinkingStatusElement.textContent = '깜빡임';
          blinkingStatusElement.style.color = '#f59e0b';
        } else if (blinkStatus === 'closed') {
          blinkingStatusElement.textContent = '눈 감음';
          blinkingStatusElement.style.color = '#ef4444';
        }
      } else {
        blinkingStatusElement.textContent = '분석 대기 중';
        blinkingStatusElement.style.color = '#6b7280';
      }
    }
    
    console.log(`[UI] 깜빡임 점수 업데이트 (${dataSource}):`, blinkScore);
    
    // 표정 분석 결과 처리 (PyTorch 모델 기반)
    let expressionScore = lastExpressionScore; // 이전 값 유지
    let expressionText = lastExpressionText; // 이전 값 유지
    const currentTime = Date.now();
    
    if (metrics?.expressionAnalysis?.success) {
      // PyTorch 모델 분석 결과 사용
      const expressionResult = metrics.expressionAnalysis;
      const scoreResult = expressionResult.score;
      
      if (scoreResult && typeof scoreResult.score === 'number') {
        // 2초마다 업데이트하거나 신뢰도가 높을 때만 업데이트
        if (currentTime - lastExpressionUpdate > EXPRESSION_UPDATE_INTERVAL || 
            expressionResult.confidence > 0.6) {
          expressionScore = scoreResult.score;
          expressionText = scoreResult.label || '중립적';
          lastExpressionScore = expressionScore;
          lastExpressionText = expressionText;
          lastExpressionUpdate = currentTime;
        }
        
        // 표정 데이터를 전역 변수에 저장 (팝업용)
        currentExpressionData = {
          expression: expressionResult.expression,
          confidence: expressionResult.confidence,
          probabilities: expressionResult.probabilities,
          score: scoreResult,
          timestamp: Date.now()
        };
        console.log('[UI] 표정 데이터 저장:', currentExpressionData);
        
        console.log('[UI] 🎭 PyTorch 표정 분석 결과:', {
          expression: expressionResult.expression,
          confidence: expressionResult.confidence,
          score: expressionScore,
          label: expressionText,
          base_score: scoreResult.base_score,
          confidence_bonus: scoreResult.confidence_bonus
        });
      }
    } else if (metrics?.smileIntensity !== undefined) {
      // 기존 MediaPipe 미소 분석 사용 (백업)
      const smileIntensity = metrics.smileIntensity;
      const personalBaseSmile = metrics.personalBaseSmile || 30;
      
      // 개인별 기준 대비 상대적 평가
      const smileRatio = smileIntensity / personalBaseSmile;
      
      // 점수 계산
      if (smileRatio > 1.3) {
        expressionScore = 90;
        expressionText = '매우 따뜻함';
      } else if (smileRatio > 1.1) {
        expressionScore = 80;
        expressionText = '따뜻함';
      } else if (smileRatio > 0.9) {
        expressionScore = 70;
        expressionText = '긍정적';
      } else if (smileRatio > 0.7) {
        expressionScore = 60;
        expressionText = '중립적';
      } else {
        expressionScore = 40;
        expressionText = '개선 필요';
      }
      
      console.log('[UI] MediaPipe 미소 분석 결과:', {
        smileIntensity,
        smileRatio,
        expressionScore,
        expressionText
      });
    } else if (metrics?.labels?.expression) {
      expressionText = metrics.labels.expression;
      expressionScore = 60; // 기본값
    }
    
    // 표정 점수 업데이트
    const expressionScoreElement = document.getElementById('expression-score');
    if (expressionScoreElement) {
      expressionScoreElement.textContent = `${expressionScore}%`;
      updateScoreColor(expressionScoreElement, expressionScore);
      
      // 종합 점수 계산기에 표정 점수 업데이트
      if (window.ComprehensiveScoreCalculator) {
        window.ComprehensiveScoreCalculator.updateVisualScore('expression', expressionScore);
      }
    }
    
    // 표정 분석 상태 업데이트 (평가 라벨 표시)
    const expressionStatusElement = document.getElementById('expression-status');
    if (expressionStatusElement) {
      if (metrics?.expressionAnalysis?.success) {
        const scoreResult = metrics.expressionAnalysis.score;
        if (scoreResult && scoreResult.label) {
          expressionStatusElement.textContent = scoreResult.label;
          // 라벨에 따른 색상 설정
          if (scoreResult.label.includes('긍정적')) {
            expressionStatusElement.style.color = '#10b981'; // 초록색
          } else if (scoreResult.label.includes('중립적')) {
            expressionStatusElement.style.color = '#f59e0b'; // 주황색
          } else {
            expressionStatusElement.style.color = '#ef4444'; // 빨간색
          }
        } else {
          expressionStatusElement.textContent = '분석 중';
          expressionStatusElement.style.color = '#6b7280';
        }
      } else {
        expressionStatusElement.textContent = '분석 대기 중';
        expressionStatusElement.style.color = '#6b7280';
      }
    }
    
    console.log(`[UI] 표정 점수 업데이트 (${dataSource}):`, { expressionScore, expressionText });
    
    // 점수 색상 업데이트 함수
    function updateScoreColor(element, score) {
      // 기존 색상 클래스 제거
      element.classList.remove('excellent', 'good', 'fair', 'poor');
      
      // 점수에 따른 색상 클래스 추가
      if (score >= 80) {
        element.classList.add('excellent');
        element.setAttribute('data-score', 'excellent');
      } else if (score >= 60) {
        element.classList.add('good');
        element.setAttribute('data-score', 'good');
      } else if (score >= 40) {
        element.classList.add('fair');
        element.setAttribute('data-score', 'fair');
      } else {
        element.classList.add('poor');
        element.setAttribute('data-score', 'poor');
      }
      
      // 업데이트 애니메이션 추가
      element.classList.add('updating');
      setTimeout(() => {
        element.classList.remove('updating');
      }, 300);
    }
    
    // 개인화된 꿀팁 업데이트
    const tips = generatePersonalizedTips(metrics);
    const tipsContainer = document.getElementById('ai-feedback-summary');
    if (tipsContainer && tips.length > 0) {
      tipsContainer.innerHTML = `
        <div style="font-weight: 700; margin-bottom: 8px; color: #1a1a1a; font-size: 14px;">🍯 실시간 꿀팁!</div>
        <ol style="padding-left: 20px; margin: 0; font-size: 13px; line-height: 1.7; color: #2d2d2d; font-weight: 500;">
          ${tips.map(tip => `<li>${tip}</li>`).join('')}
        </ol>
      `;
    }
    
  } catch (e) {
    console.warn('[ANALYZER] UI update error', e);
  }
}







function clamp01To100(v) {
  if (v == null || isNaN(v)) return null;
  if (v <= 1) return Math.round(v * 100);
  return Math.round(Math.max(0, Math.min(100, v)));
}

function mapFrameResultToMetrics(result) {
  // 얼굴 인식 상태 확인 (완화: ear_value 조건 제거)
  const cameraBlocked = result?.coaching_message === '카메라가 보이지 않아서 피드백을 할 수 없습니다.';
  const noFace = result?.status === 'no-face';
  const isFaceDetected = !(cameraBlocked || noFace);
  
  // 얼굴이 전혀 감지되지 않는 명시적 경우만 0으로
  if (!isFaceDetected) {
    return {
      scores: { attention: 0, stability: 0, blink: 0, posture: 0 },
      labels: { expression: '-' },
      status: result?.status || 'no-face',
      coaching_message: result?.coaching_message,
      ear_value: result?.ear_value,
      frame_processed: result?.frame_processed === true
    };
  }
  
  // 다양한 결과 포맷을 5개 지표로 적응 매핑
  const scores = {};
  const labels = {};

  // 우선순위 1: result.scores에 A,S,R,P,W 등이 존재하는 경우
  const s = result?.scores || {};
  if (typeof s.A !== 'undefined') scores.attention = clamp01To100(s.A);
  if (typeof s.S !== 'undefined') scores.stability = clamp01To100(s.S);
  if (typeof s.R !== 'undefined') scores.blink = clamp01To100(s.R); // Relax≈Blink proxy
  // P는 백업으로만 사용 (개별 점수들이 우선)
  if (typeof s.P !== 'undefined' && s.P > 0) {
    scores.posture_backup = clamp01To100(s.P);
  }
  if (typeof s.W !== 'undefined') {
    const w = clamp01To100(s.W);
    labels.expression = w != null ? (w >= 66 ? '긍정적' : w >= 40 ? '중립적' : '개선 필요') : undefined;
  }

  // 우선순위 2: 개별 필드 명시적 값
  if (scores.attention == null && typeof result.attention === 'number') scores.attention = clamp01To100(result.attention);
  if (scores.stability == null && typeof result.stability_score === 'number') scores.stability = clamp01To100(result.stability_score);
  if (scores.stability == null && typeof result.stability === 'number') scores.stability = clamp01To100(result.stability);
  if (scores.blink == null && typeof result.blink === 'number') scores.blink = clamp01To100(result.blink);
  
  // 자세 점수 우선순위: 개별 점수들 > enhanced_posture_score > posture_score > posture > scores.P 백업
  
  // 1. 개별 자세 점수들을 우선적으로 계산
  const individualScores = [];
  if (typeof result.chin_forward_score === 'number') individualScores.push(result.chin_forward_score);
  if (typeof result.neck_tilt_score === 'number') individualScores.push(result.neck_tilt_score);
  if (typeof result.neck_score === 'number') individualScores.push(result.neck_score);
  if (typeof result.back_score === 'number') individualScores.push(result.back_score);
  if (typeof result.shoulder_blade_score === 'number') individualScores.push(result.shoulder_blade_score);
  if (typeof result.shoulder_width_score === 'number') individualScores.push(result.shoulder_width_score);
  if (typeof result.torso_height_score === 'number') individualScores.push(result.torso_height_score);
  if (typeof result.neck_length_score === 'number') individualScores.push(result.neck_length_score);
  if (typeof result.neck_angle_score === 'number') individualScores.push(result.neck_angle_score);
  
  if (individualScores.length > 0) {
    const avgIndividualScore = individualScores.reduce((a, b) => a + b, 0) / individualScores.length;
    scores.posture = clamp01To100(avgIndividualScore);
  }
  
  // 2. 백업 점수들
  if (scores.posture == null && typeof result.enhanced_posture_score === 'number') {
    scores.posture = clamp01To100(result.enhanced_posture_score);
  }
  if (scores.posture == null && typeof result.posture_score === 'number') {
    scores.posture = clamp01To100(result.posture_score);
  }
  if (scores.posture == null && typeof result.posture === 'number') {
    scores.posture = clamp01To100(result.posture);
  }

  // 추가 후보 키들
  if (scores.attention == null && typeof result.attention_score === 'number') scores.attention = clamp01To100(result.attention_score);
  if (scores.attention == null && typeof result.focus === 'number') scores.attention = clamp01To100(result.focus);
  if (scores.attention == null && typeof result.focus_score === 'number') scores.attention = clamp01To100(result.focus_score);
  if (scores.attention == null && typeof result.gaze_attention === 'number') scores.attention = clamp01To100(result.gaze_attention);
  if (scores.blink == null && typeof result.blink_score === 'number') scores.blink = clamp01To100(result.blink_score);
  if (scores.blink == null && typeof result.blinking === 'number') scores.blink = clamp01To100(result.blinking);

  // 3. 기하학적 측정값 기반 점수 (개별 점수보다 우선)
  if (scores.posture == null) {
    // 3a. 상태 문자열 기반 점수 (개별 점수들이 없을 때만 사용)
    const hasIndividualScores = individualScores.length > 0;
    
    if (!hasIndividualScores) {
      const status = typeof result.posture_status === 'string' ? result.posture_status.toLowerCase() : '';
      const enhancedStatus = typeof result.enhanced_posture_status === 'string' ? result.enhanced_posture_status.toLowerCase() : '';
      const backStatus = typeof result.back_status === 'string' ? result.back_status.toLowerCase() : '';
      const neckStatus = typeof result.neck_status === 'string' ? result.neck_status.toLowerCase() : '';
      
      if (status || enhancedStatus || backStatus || neckStatus) {
        const allStatuses = [status, enhancedStatus, backStatus, neckStatus].filter(s => s);
        let maxScore = 0;
        
        for (const s of allStatuses) {
          if (s.includes('매우 좋') || s.includes('excellent') || s.includes('best')) maxScore = Math.max(maxScore, 95);
          else if (s.includes('좋') || s.includes('good')) maxScore = Math.max(maxScore, 85);
          else if (s.includes('보통') || s.includes('ok') || s.includes('neutral')) maxScore = Math.max(maxScore, 70);
          else if (s.includes('개선') || s.includes('나쁨') || s.includes('bad')) maxScore = Math.max(maxScore, 50); // 35 → 50으로 완화
          else if (s.includes('데이터없음') || s.includes('no data')) maxScore = Math.max(maxScore, 0);
        }
        
        if (maxScore > 0) scores.posture = maxScore;
      }
    }
    
    // 3b. 기하학적 측정값 기반 점수 (더 정교한 계산)
    if (scores.posture == null) {
      const fwd = typeof result.forward_head === 'number' ? Math.abs(result.forward_head) : null;
      const tilt = typeof result.shoulder_tilt === 'number' ? Math.abs(result.shoulder_tilt) : null;
      const fwdRatio = typeof result.forward_head_ratio === 'number' ? Math.abs(result.forward_head_ratio) : null;
      const shoulderOpen = typeof result.shoulder_open_deg === 'number' ? result.shoulder_open_deg : null;
      const torsoLean = typeof result.torso_lean_deg === 'number' ? result.torso_lean_deg : null;
      // 골반 각도 제거 요청에 따라 제외
      const pelvisOpen = null;
      
      if (fwd != null || tilt != null || fwdRatio != null || shoulderOpen != null || torsoLean != null) {
        let totalPenalty = 0;
        let factorCount = 0;
        
        // 전방두 페널티 (0.35 이하가 좋음)
        if (fwd != null) {
          const nf = Math.min(1, fwd / 0.35);
          totalPenalty += nf * 30;
          factorCount++;
        }
        
        // 어깨 기울임 페널티 (가중치 상향)
        if (tilt != null) {
          const nt = Math.min(1, tilt / 0.25);
          totalPenalty += nt * 35; // 25 → 35
          factorCount++;
        }
        
        // 전방두 비율 페널티 (0.5 이하가 좋음)
        if (fwdRatio != null) {
          const nfr = Math.min(1, fwdRatio / 0.5);
          totalPenalty += nfr * 20;
          factorCount++;
        }
        
        // 어깨 각도 페널티 (가중치 상향, 170-180도가 좋음)
        if (shoulderOpen != null) {
          const so = Math.abs(shoulderOpen - 175) / 10; // 175도 기준
          const nso = Math.min(1, so);
          totalPenalty += nso * 25; // 15 → 25
          factorCount++;
        }
        
        // 몸통 기울임 페널티 (175-185도가 좋음)
        if (torsoLean != null) {
          const tl = Math.abs(torsoLean - 180) / 10; // 180도 기준
          const ntl = Math.min(1, tl);
          totalPenalty += ntl * 10;
          factorCount++;
        }
        
        // 골반 각도는 평가에서 제외
        
        // 평균 페널티 계산
        const avgPenalty = factorCount > 0 ? totalPenalty / factorCount : 0;
        const base = 100;
        scores.posture = Math.round(Math.max(0, Math.min(100, base - avgPenalty)));
      }
    }
    
    // 4. 백업 점수들 (scores.P 등)
    if (scores.posture == null && scores.posture_backup != null) {
      scores.posture = scores.posture_backup;
    }
  }

  // 자세 디버그 로깅 활성화
  if (window.__ANALYZER_DEBUG_POSTURE__ && window.__ANALYZER_DEBUG_POSTURE__ < 20) {
    console.log('[ANALYZER][POSTURE]', {
      // 직접 점수
      from_scores_P: result?.scores?.P,
      enhanced_posture_score: result?.enhanced_posture_score,
      posture_score: result?.posture_score,
      posture: result?.posture,
      
      // 상태 문자열
      posture_status: result?.posture_status,
      enhanced_posture_status: result?.enhanced_posture_status,
      back_status: result?.back_status,
      neck_status: result?.neck_status,
      
      // 기하학적 측정값
      forward_head: result?.forward_head,
      forward_head_ratio: result?.forward_head_ratio,
      shoulder_tilt: result?.shoulder_tilt,
      shoulder_open_deg: result?.shoulder_open_deg,
      torso_lean_deg: result?.torso_lean_deg,
      pelvis_open_deg: result?.pelvis_open_deg,
      
      // 개별 점수
      back_score: result?.back_score,
      neck_score: result?.neck_score,
      chin_forward_score: result?.chin_forward_score,
      neck_tilt_score: result?.neck_tilt_score,
      shoulder_blade_score: result?.shoulder_blade_score,
      shoulder_width_score: result?.shoulder_width_score,
      torso_height_score: result?.torso_height_score,
      neck_length_score: result?.neck_length_score,
      neck_angle_score: result?.neck_angle_score,
      
      // 최종 결과
      mapped: scores.posture,
      individual_scores_count: individualScores.length,
      individual_scores_avg: individualScores.length > 0 ? individualScores.reduce((a, b) => a + b, 0) / individualScores.length : null,
      
      // 계산 방식
      calculation: {
        direct_score: (result?.scores?.P != null || result?.enhanced_posture_score != null || result?.posture_score != null || result?.posture != null) ? 'yes' : 'no',
        status_based: (result?.posture_status || result?.enhanced_posture_status || result?.back_status || result?.neck_status) ? 'yes' : 'no',
        geometry_based: (result?.forward_head != null || result?.shoulder_tilt != null || result?.forward_head_ratio != null || result?.shoulder_open_deg != null || result?.torso_lean_deg != null || result?.pelvis_open_deg != null) ? 'yes' : 'no',
        individual_scores: (result?.back_score != null || result?.neck_score != null) ? 'yes' : 'no'
      }
    });
    window.__ANALYZER_DEBUG_POSTURE__ += 1;
  }

  // 우선순위 3: 서버에서 기존 피드백 스타일 키 사용 시
  if (scores.stability == null && typeof result.gaze_stability === 'number') scores.stability = clamp01To100(result.gaze_stability);
  if (scores.attention == null && typeof result.concentration === 'number') scores.attention = clamp01To100(result.concentration);
  if (scores.posture == null && typeof result.posture === 'number') scores.posture = clamp01To100(result.posture);
  if (scores.blink == null && typeof result.blinking === 'number') scores.blink = clamp01To100(result.blinking);

  // 보조: blink_rate(Hz/min)를 0-100으로 근사 맵핑
  if (scores.blink == null && typeof result.blink_rate === 'number') {
    // 10~25 범위를 70~30으로 뒤집어 맵핑 (낮을수록 안정)
    const br = result.blink_rate;
    const norm = 100 - Math.max(0, Math.min(100, (br - 10) * 5));
    scores.blink = Math.round(norm);
  }

  // 표정/미소
  if (!labels.expression) {
    if (typeof result.smile_score === 'number') {
      const w = clamp01To100(result.smile_score);
      labels.expression = w != null ? (w >= 66 ? '긍정적' : w >= 40 ? '중립적' : '개선 필요') : undefined;
    } else if (typeof result.warmth_label === 'string') {
      labels.expression = result.warmth_label;
    } else if (typeof result.expression === 'string') {
      labels.expression = result.expression;
    }
  }

  // 최종 보정: null 채우기 + 원본 상태 전달
  const out = {
    scores: {
      attention: scores.attention ?? 0,
      stability: scores.stability ?? 0,
      blink: scores.blink ?? 0,
      posture: scores.posture ?? 0
    },
    labels: { expression: labels.expression ?? '-' },
    status: result?.status,
    coaching_message: result?.coaching_message,
    ear_value: result?.ear_value,
    frame_processed: result?.frame_processed === true
  };
  return out;
}

// scheduleAnalyzerStart 함수는 js/camera-analyzer.js에서 제공됨

// --- AI API는 서버에서 처리됨 (OpenAI GPT-4o-mini 사용) ---

 // --- 초기 안내 팝업 제어 함수 ---
 function showInitialGuidePopup() {
     document.getElementById('initial-guide-overlay').classList.add('visible');
 }
 
   function hideInitialGuidePopup() {
      document.getElementById('initial-guide-overlay').classList.remove('visible');

  }
 

 
   // --- 카메라 경고 메시지 제어 함수 ---
  function showCameraWarning() {
      // 상단 바 스타일 경고 메시지 표시
      document.getElementById('camera-warning').classList.remove('hidden');
      document.getElementById('main-content').classList.add('with-warning');
  }
  
  function hideCameraWarning() {
      document.getElementById('camera-warning').classList.add('hidden');
      document.getElementById('main-content').classList.remove('with-warning');
  }
  
  // --- 인라인 카메라 경고 메시지 제어 함수 ---
  function showCameraWarningInline() {
      document.getElementById('camera-warning-inline').style.display = 'block';
  }
  
  function hideCameraWarningInline() {
      document.getElementById('camera-warning-inline').style.display = 'none';
  }
  
  // --- 카메라 토스트 경고 메시지 제어 함수 ---
  function showCameraToast() {
      document.getElementById('camera-toast').classList.remove('hidden');
      // 5초 후 자동으로 숨기기
      setTimeout(() => {
          hideCameraToast();
      }, 5000);
  }
  
  function hideCameraToast() {
      document.getElementById('camera-toast').classList.add('hidden');
  }
  
  // --- 확인 팝업 제어 함수 ---
  function showConfirmDialog() {
      document.getElementById('confirm-overlay').classList.add('visible');
  }
  
  function hideConfirmDialog() {
      document.getElementById('confirm-overlay').classList.remove('visible');
  }

// --- 채팅 관련 변수 ---
let chatHistory = [];
let currentSessionId = null; // MongoDB 세션 ID

// --- 피드백 패널 제어 ---
function toggleFeedbackPanel() { 
    feedbackPanel.classList.toggle('visible'); 
}

// --- 채팅 기능 ---
function addPersonaCard() {
    if (!personaName) return;
    
    const personaCard = document.createElement('div');
    personaCard.className = 'persona-card';
    
    // 성별에 따른 클래스 추가 (이미지 파일명으로 판단)
    const imageFileName = personaImage ? personaImage.split('/').pop() : '';
    if (imageFileName.includes('woman') || imageFileName.includes('female')) {
        personaCard.classList.add('female');
    } else if (imageFileName.includes('man') || imageFileName.includes('male')) {
        personaCard.classList.add('male');
    }
    
    const personalityArray = personaPersonality ? personaPersonality.split(',') : [];
    
    // 이미지 경로 수정
            const imagePath = personaImage ? `${window.serverUrl || 'https://dys-phi.vercel.app/api/gke'}/dys_studio/img/persona/${personaImage.split('/').pop()}` : '/img/default-avatar.png';
    
    personaCard.innerHTML = `
        <div class="persona-header">
            <img src="${imagePath}" alt="${personaName}" class="persona-avatar">
            <div class="persona-info">
                <h4>${personaName}</h4>
                <p>${personaAge}세 · ${personaJob}</p>
            </div>
        </div>
        <div class="persona-details">
            <span class="persona-tag">${personaMbti}</span>
            ${personalityArray.map(trait => `<span class="persona-tag">${trait.trim()}</span>`).join('')}
        </div>
    `;
    
    chatLog.appendChild(personaCard);
    chatLog.scrollTop = chatLog.scrollHeight;
}

function addBubble(text, role) {
    const bubble = document.createElement('div');
    bubble.className = `bubble ${role}`;
    bubble.innerHTML = text;
    chatLog.appendChild(bubble);
    chatLog.scrollTop = chatLog.scrollHeight;
}

function showTypingIndicator() {
    const typingBubble = document.createElement('div');
    typingBubble.className = 'bubble typing';
    typingBubble.innerHTML = '<span></span><span></span><span></span>';
    chatLog.appendChild(typingBubble);
    chatLog.scrollTop = chatLog.scrollHeight;
}

function removeTypingIndicator() {
    const typingBubble = chatLog.querySelector('.typing');
    if (typingBubble) chatLog.removeChild(typingBubble);
}

   async function sendMessage() {
    const text = chatInput.value.trim();
    if(!text) return;
  
    // 중복 전송 방지
    if (window._sendingMessage) {
        console.log('[CHAT] 이미 메시지 전송 중, 중복 방지');
        return;
    }
    window._sendingMessage = true;
  
    try {
        addBubble(text, 'me');
        chatHistory.push({ role: "user", content: text });
        
        // 대화 주도권 분석 업데이트
        if (window.ConversationAnalyzer) {
            window.ConversationAnalyzer.addMessage("user", text);
        }
        
        chatInput.value = '';
        chatInput.focus();
        showTypingIndicator();
      
        // 서버 API로 메시지 전송 (MongoDB 저장 + AI 응답 생성)
        const response = await fetch(`${window.serverUrl || 'https://dys-phi.vercel.app/api/gke'}/api/chat/sessions/${currentSessionId}/messages`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                content: text,
                role: 'user',
                user_id: userId,
                email: email
            })
        });

        if (response.ok) {
            const result = await response.json();
            console.log('✅ [CHAT] 메시지 전송 성공:', result);
            
            removeTypingIndicator();
            
            // AI 응답이 있으면 표시
            if (result.ai_response) {
                addBubble(result.ai_response, 'ai');
                chatHistory.push({ role: "assistant", content: result.ai_response });
                
                // AI 응답도 대화 주도권 분석에 추가
                if (window.ConversationAnalyzer) {
                    window.ConversationAnalyzer.addMessage("assistant", result.ai_response);
                }
                
                // TTS로 AI 응답 읽어주기 (대화 내용만 정리)
                if (window.ttsManager && window.ttsManager.isEnabled) {
                    setTimeout(() => {
                        console.log('[TTS] 원본 AI 응답:', result.ai_response);
                        const cleanText = cleanTextForTTS(result.ai_response);
                        if (cleanText && cleanText.trim().length > 0) {
                            console.log('[TTS] 정리된 텍스트로 TTS 호출:', cleanText);
                            window.ttsManager.speak(cleanText);
                        } else {
                            console.warn('[TTS] 정리 후 텍스트가 비어있어 TTS 호출하지 않음');
                        }
                    }, 500); // 0.5초 후 음성 재생 (채팅 버블 애니메이션 완료 후)
                }
            }
        } else {
            throw new Error(`서버 응답 오류: ${response.status}`);
        }
        
    } catch (error) {
        console.error('[CHAT] 메시지 전송 실패:', error);
        removeTypingIndicator();
        const errorMessage = "죄송해요, 잠시 후 다시 시도해 주세요.";
        addBubble(errorMessage, 'ai');
        chatHistory.push({ role: "assistant", content: errorMessage });
    } finally {
        window._sendingMessage = false;
    }
}

// --- TTS용 텍스트 정리 함수 ---
function cleanTextForTTS(text) {
    if (!text || typeof text !== 'string') {
        console.warn('[TTS] 유효하지 않은 텍스트:', text);
        return null;
    }
    
    console.log('[TTS] 원본 텍스트:', text);
    
    // 1. HTML 태그 및 SSML 태그 제거
    let cleanText = text
        .replace(/<[^>]*>/g, '') // HTML 태그 제거
        .replace(/<speak[^>]*>/gi, '') // SSML speak 태그 제거
        .replace(/<\/speak>/gi, '') // SSML speak 닫기 태그 제거
        .replace(/<prosody[^>]*>/gi, '') // SSML prosody 태그 제거
        .replace(/<\/prosody>/gi, '') // SSML prosody 닫기 태그 제거
        .replace(/<voice[^>]*>/gi, '') // SSML voice 태그 제거
        .replace(/<\/voice>/gi, '') // SSML voice 닫기 태그 제거
        .replace(/<break[^>]*>/gi, '') // SSML break 태그 제거
        .replace(/<emphasis[^>]*>/gi, '') // SSML emphasis 태그 제거
        .replace(/<\/emphasis>/gi, '') // SSML emphasis 닫기 태그 제거
        .replace(/<say-as[^>]*>/gi, '') // SSML say-as 태그 제거
        .replace(/<\/say-as>/gi, '') // SSML say-as 닫기 태그 제거
        .replace(/<phoneme[^>]*>/gi, '') // SSML phoneme 태그 제거
        .replace(/<\/phoneme>/gi, '') // SSML phoneme 닫기 태그 제거
        .replace(/<sub[^>]*>/gi, '') // SSML sub 태그 제거
        .replace(/<\/sub>/gi, '') // SSML sub 닫기 태그 제거
        .replace(/<audio[^>]*>/gi, '') // SSML audio 태그 제거
        .replace(/<mark[^>]*>/gi, '') // SSML mark 태그 제거
        .replace(/<bookmark[^>]*>/gi, '') // SSML bookmark 태그 제거
        .replace(/<p[^>]*>/gi, '') // SSML p 태그 제거
        .replace(/<\/p>/gi, '') // SSML p 닫기 태그 제거
        .replace(/<s[^>]*>/gi, '') // SSML s 태그 제거
        .replace(/<\/s>/gi, '') // SSML s 닫기 태그 제거
        .replace(/<w[^>]*>/gi, '') // SSML w 태그 제거
        .replace(/<\/w>/gi, '') // SSML w 닫기 태그 제거
        .replace(/<m[^>]*>/gi, '') // SSML m 태그 제거
        .replace(/<\/m>/gi, '') // SSML m 닫기 태그 제거
        .replace(/<t[^>]*>/gi, '') // SSML t 태그 제거
        .replace(/<\/t>/gi, '') // SSML t 닫기 태그 제거
        .replace(/xmlns="[^"]*"/gi, '') // XML 네임스페이스 제거
        .replace(/xml:lang="[^"]*"/gi, '') // XML 언어 속성 제거
        .replace(/version="[^"]*"/gi, ''); // XML 버전 속성 제거
    
    // 2. 특수 문자 및 이모지 정리
    cleanText = cleanText
        .replace(/[🎤🎬📹🎥🎭🎪🎨🎯🎲🎮🎰🎱🎳🎴🎵🎶🎷🎸🎹🎺🎻🎼🎽🎾🎿🏀🏁🏂🏃🏄🏅🏆🏇🏈🏉🏊🏋🏌🏍🏎🏏🏐🏑🏒🏓🏔🏕🏖🏗🏘🏙🏚🏛🏜🏝🏞🏟🏠🏡🏢🏣🏤🏥🏦🏧🏨🏩🏪🏫🏬🏭🏮🏯🏰🏱🏲🏳🏴🏵🏶🏷🏸🏹🏺🏻🏼🏽🏾🏿]/g, '') // 이모지 제거
        .replace(/[🔴🟠🟡🟢🔵🟣⚫⚪🟤🔺🔻🔸🔹🔶🔷🔳🔲▪️▫️◾◽◼️◻️🟥🟧🟨🟩🟦🟪⬛⬜🟫]/g, '') // 색상 이모지 제거
        .replace(/[📱📲📳📴📵📶📷📸📹📺📻📼📽📾📿🔀🔁🔂🔄🔃⏩⏪⏫⏬⏭⏮⏯⏰⏱⏲⏳⏸⏹⏺⏻]/g, '') // 기타 이모지 제거
        .replace(/[💻💼💽💾💿📀📁📂📃📄📅📆📇📈📉📊📋📌📍📎📏📐📑📒📓📔📕📖📗📘📙📚📛📜📝📞📟📠📡📢📣📤📥📦📧📨📩📪📫📬📭📮📯📰📱📲📳📴📵📶📷📸📹📺📻📼📽📾📿]/g, '') // 더 많은 이모지 제거
        .replace(/[😀😃😄😁😆😅😂🤣😊😇🙂🙃😉😌😍🥰😘😗😙😚😋😛😝😜🤪🤨🧐🤓😎🤩🥳😏😒😞😔😟😕🙁☹️😣😖😫😩🥺😢😭😤😠😡🤬🤯😳🥵🥶😱😨😰😥😓🤗🤔🤭🤫🤥😶😐😑😯😦😧😮😲🥱😴🤤😪😵🤐🥴🤢🤮🤧😷🤒🤕🤑🤠]/g, '') // 감정 이모지 제거
        .replace(/[👋🤚🖐️✋🖖👌🤌🤏✌️🤞🤟🤘🤙👈👉👆🖕👇☝️👍👎✊👊👋👌✌️🤞🤟🤘🤙👈👉👆🖕👇☝️👍👎✊👊]/g, '') // 손 이모지 제거
        .replace(/[👶👧🧒👦👩🧑👨👵🧓👴👲👳🧕👮🕵️👷👸🤴👳👲🧕👮🕵️👷👸🤴]/g, '') // 사람 이모지 제거
        .replace(/[🐶🐱🐭🐹🐰🦊🐻🐼🐻‍❄️🐨🐯🦁🐮🐷🐽🐸🐵🙈🙉🙊🐒🐔🐧🐦🐤🐣🐥🦆🦅🦉🦇🐺🐗🐴🦄🐝🐛🦋🐌🐞🐜🦟🦗🕷️🕸️🦂🐢🐍🦎🦖🦕🐙🦑🦐🦞🦀🐡🐠🐟🐬🐳🐋🦈🐊🐅🐆🦓🦍🦧🐘🦛🦏🐪🐫🦙🦒🐃🐂🐄🐎🐖🐏🐑🦌🐕🐩🦮🐕‍🦺🐈🐈‍⬛🐓🦃🦚🦜🦢🦩🕊️🐇🦝🦨🦡🦫🦦🦥🐁🐀🐿️🦔]/g, '') // 동물 이모지 제거
        .replace(/[🌱🌲🌳🌴🌵🌾🌿☘️🍀🍁🍂🍃🍄🍄‍🟫🍅🍆🌶️🌽🥕🥬🥒🥦🧄🧅🥜🌰🥑🥥🥝🥭🍎🍐🍊🍋🍌🍉🍇🍓🫐🍈🍒🍑🥭🍍🥥🥝🍅🍆🥑🥦🥬🥒🌶️🧄🧅🥕🥜🌰🥑🥥🥝🥭🍎🍐🍊🍋🍌🍉🍇🍓🫐🍈🍒🍑🥭🍍🥥🥝🍅🍆🥑🥦🥬🥒🌶️🧄🧅🥕🥜🌰]/g, '') // 식물 이모지 제거
        .replace(/[🍔🍟🍕🌭🥪🌮🌯🥙🧆🥚🍳🧈🥞🧇🥓🥩🍗🍖🦴🌭🍔🍟🍕🥪🥙🧆🌮🌯🥗🥘🥫🍝🍜🍲🍛🍣🍱🥟🦪🍤🍙🍚🍘🍥🥠🥮🍢🍡🍧🍨🍦🥧🧁🍰🎂🍮🍭🍬🍫🍿🍩🍪🌰🥜🍯🥛🍼☕🫖🍵🧃🥤🧋🍶🍺🍻🥂🍷🥃🍸🍹🍾🥄🍴🍽️🥡🥢🧂]/g, '') // 음식 이모지 제거
        .replace(/[⚽🏀🏈⚾🥎🎾🏐🏉🥏🎱🪀🏓🏸🏒🏑🥍🏏🥅⛳🪁🏹🎣🤿🥊🥋🎽🛹🛷⛸️🥌🎿⛷️🏂🪂🏋️‍♀️🏋️‍♂️🤼‍♀️🤼‍♂️🤸‍♀️🤸‍♂️⛹️‍♀️⛹️‍♂️🤺🤾‍♀️🤾‍♂️🏊‍♀️🏊‍♂️🚣‍♀️🚣‍♂️🧗‍♀️🧗‍♂️🚵‍♀️🚵‍♂️🚴‍♀️🚴‍♂️🏆🥇🥈🥉🏅🎖️🏵️🎗️🎫🎟️🎪🤹‍♀️🤹‍♂️🎭🩰🎨🎬🎤🎧🎼🎹🥁🎷🎺🎸🪕🎻🎲♟️🎯🎳🎮🎰🧩🎨📱📲💻⌨️🖥️🖨️🖱️🖲️💽💾💿📀📼📷📸📹📺📻📟📠🔋🔌💡🔦🕯️🪔🧯🛢️💸💵💴💶💷🪙💰💳💎⚖️🪜🪝🔧🔨⚒️🛠️⛏️🪛🔩⚙️🪤🧰🧲🪜🪝🔧🔨⚒️🛠️⛏️🪛🔩⚙️🪤🧰🧲]/g, '') // 스포츠/기타 이모지 제거
        .replace(/[🚗🚕🚙🚌🚎🏎️🚓🚑🚒🚐🛻🚚🚛🚜🛺🚔🚍🚘🚖🚡🚠🚟🚃🚋🚞🚝🚄🚅🚈🚂🚆🚇🚊🚉✈️🛫🛬🛩️💺🛰️🚀🛸🚁🛶⛵🚤🛥️🛳️⛴️🚢⚓🪝⛽🚧🚨🚥🚦🛑🚏🗺️🗿🗽🗼🏰🏯🏟️🎡🎢🎠⛲⛱️🏖️🏝️🏔️⛰️🌋🗻🏕️⛺🏠🏡🏘️🏚️🏗️🏭🏢🏬🏣🏤🏥🏦🏨🏪🏫🏩💒🏛️⛪🕌🕍🛕🕋⛩️🪔🎇🎆🧨✨🎈🎉🎊🎋🎍🎎🎏🎐🎀🎁🪄🪅🎊🎉🎈✨🧨🎆🎇🪔⛩️🕋🛕🕍🕌⛪🏛️💒🏩🏫🏪🏨🏦🏥🏤🏣🏬🏢🏭🏗️🏚️🏘️🏡🏠⛺🏕️🗻🌋⛰️🏔️🏝️🏖️⛱️⛲🎠🎢🎡🏟️🏯🏰🗼🗽🗿🗺️🚏🛑🚦🚥🚨🚧⛽🪝⚓🚢⛴️🛳️🛥️🚤⛵🛶🚁🛸🚀🛰️💺🛩️🛬🛫✈️🚊🚇🚆🚂🚈🚅🚄🚝🚞🚋🚃🚟🚠🚡🚖🚘🚍🚔🛺🚜🚛🚚🛻🚐🚒🚑🚓🏎️🚎🚌🚙🚕🚗]/g, '') // 교통/건물 이모지 제거
        .replace(/[🌍🌎🌏🌐🗺️🗾🧭🏔️⛰️🌋🗻🏕️⛺🏠🏡🏘️🏚️🏗️🏭🏢🏬🏣🏤🏥🏦🏨🏪🏫🏩💒🏛️⛪🕌🕍🛕🕋⛩️🪔🎇🎆🧨✨🎈🎉🎊🎋🎍🎎🎏🎐🎀🎁🪄🪅🎊🎉🎈✨🧨🎆🎇🪔⛩️🕋🛕🕍🕌⛪🏛️💒🏩🏫🏪🏨🏦🏥🏤🏣🏬🏢🏭🏗️🏚️🏘️🏡🏠⛺🏕️🗻🌋⛰️🏔️🏝️🏖️⛱️⛲🎠🎢🎡🏟️🏯🏰🗼🗽🗿🗺️🚏🛑🚦🚥🚨🚧⛽🪝⚓🚢⛴️🛳️🛥️🚤⛵🛶🚁🛸🚀🛰️💺🛩️🛬🛫✈️🚊🚇🚆🚂🚈🚅🚄🚝🚞🚋🚃🚟🚠🚡🚖🚘🚍🚔🛺🚜🚛🚚🛻🚐🚒🚑🚓🏎️🚎🚌🚙🚕🚗]/g, '') // 지리/건물 이모지 제거
        .replace(/[🌍🌎🌏🌐🗺️🗾🧭🏔️⛰️🌋🗻🏕️⛺🏠🏡🏘️🏚️🏗️🏭🏢🏬🏣🏤🏥🏦🏨🏪🏫🏩💒🏛️⛪🕌🕍🛕🕋⛩️🪔🎇🎆🧨✨🎈🎉🎊🎋🎍🎎🎏🎐🎀🎁🪄🪅🎊🎉🎈✨🧨🎆🎇🪔⛩️🕋🛕🕍🕌⛪🏛️💒🏩🏫🏪🏨🏦🏥🏤🏣🏬🏢🏭🏗️🏚️🏘️🏡🏠⛺🏕️🗻🌋⛰️🏔️🏝️🏖️⛱️⛲🎠🎢🎡🏟️🏯🏰🗼🗽🗿🗺️🚏🛑🚦🚥🚨🚧⛽🪝⚓🚢⛴️🛳️🛥️🚤⛵🛶🚁🛸🚀🛰️💺🛩️🛬🛫✈️🚊🚇🚆🚂🚈🚅🚄🚝🚞🚋🚃🚟🚠🚡🚖🚘🚍🚔🛺🚜🚛🚚🛻🚐🚒🚑🚓🏎️🚎🚌🚙🚕🚗]/g, '') // 더 많은 이모지 제거
        .replace(/[🌍🌎🌏🌐🗺️🗾🧭🏔️⛰️🌋🗻🏕️⛺🏠🏡🏘️🏚️🏗️🏭🏢🏬🏣🏤🏥🏦🏨🏪🏫🏩💒🏛️⛪🕌🕍🛕🕋⛩️🪔🎇🎆🧨✨🎈🎉🎊🎋🎍🎎🎏🎐🎀🎁🪄🪅🎊🎉🎈✨🧨🎆🎇🪔⛩️🕋🛕🕍🕌⛪🏛️💒🏩🏫🏪🏨🏦🏥🏤🏣🏬🏢🏭🏗️🏚️🏘️🏡🏠⛺🏕️🗻🌋⛰️🏔️🏝️🏖️⛱️⛲🎠🎢🎡🏟️🏯🏰🗼🗽🗿🗺️🚏🛑🚦🚥🚨🚧⛽🪝⚓🚢⛴️🛳️🛥️🚤⛵🛶🚁🛸🚀🛰️💺🛩️🛬🛫✈️🚊🚇🚆🚂🚈🚅🚄🚝🚞🚋🚃🚟🚠🚡🚖🚘🚍🚔🛺🚜🚛🚚🛻🚐🚒🚑🚓🏎️🚎🚌🚙🚕🚗]/g, ''); // 최종 이모지 제거
    
    // 3. 시스템 메시지나 특수 패턴 제거 (강화된 버전)
    cleanText = cleanText
        // 기본 시스템 메시지 제거
        .replace(/^(시스템|System|ERROR|Error|error|WARNING|Warning|warning|INFO|Info|info|DEBUG|Debug|debug|LOG|Log|log):/g, '')
        .replace(/^\[.*?\]/g, '') // 대괄호로 둘러싸인 시스템 메시지 제거
        .replace(/^\{.*?\}/g, '') // 중괄호로 둘러싸인 시스템 메시지 제거
        .replace(/^<.*?>/g, '') // 꺾쇠괄호로 둘러싸인 시스템 메시지 제거
        .replace(/^\(.*?\)/g, '') // 괄호로 둘러싸인 시스템 메시지 제거
        
        // HTTP/API 관련 시스템 메시지 제거
        .replace(/^HTTP.*?OK.*?$/gm, '') // HTTP 응답 메시지 제거
        .replace(/^INFO:httpx:.*?$/gm, '') // httpx 로그 제거
        .replace(/^✅.*?$/gm, '') // 체크마크 시스템 메시지 제거
        .replace(/^🤖.*?$/gm, '') // 로봇 이모지 시스템 메시지 제거
        .replace(/^🔄.*?$/gm, '') // 리프레시 이모지 시스템 메시지 제거
        .replace(/^🔍.*?$/gm, '') // 돋보기 이모지 시스템 메시지 제거
        .replace(/^📊.*?$/gm, '') // 차트 이모지 시스템 메시지 제거
        
        // AI 응답 관련 시스템 메시지 제거
        .replace(/^\[AI_RESPONSE\].*?$/gm, '') // AI 응답 로그 제거
        .replace(/^\[SEND_MESSAGE\].*?$/gm, '') // 메시지 전송 로그 제거
        .replace(/^\[SAVE_MESSAGE\].*?$/gm, '') // 메시지 저장 로그 제거
        .replace(/^OpenAI.*?응답.*?$/gm, '') // OpenAI 응답 로그 제거
        
        // 랜드마크 관련 시스템 메시지 제거
        .replace(/^랜드마크.*?프레임.*?$/gm, '') // 랜드마크 배치 로그 제거
        .replace(/^📊.*?랜드마크.*?$/gm, '') // 랜드마크 차트 로그 제거
        
        // URL 및 도메인 제거
        .replace(/https?:\/\/[^\s]+/g, '') // HTTP/HTTPS URL 제거
        .replace(/www\.[^\s]+/g, '') // www 도메인 제거
        .replace(/[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g, '') // 일반 도메인 제거
        .replace(/\/\/[^\s]+/g, '') // //로 시작하는 경로 제거
        
        // JSON 객체 및 딕셔너리 제거
        .replace(/\{[^}]*\}/g, '') // 중괄호로 둘러싸인 JSON 객체 제거
        .replace(/\[[^\]]*\]/g, '') // 대괄호로 둘러싸인 배열 제거
        .replace(/"[^"]*":\s*"[^"]*"/g, '') // JSON 키-값 쌍 제거
        .replace(/"[^"]*":\s*[^,}\]]+/g, '') // JSON 키-값 쌍 제거 (값이 문자열이 아닌 경우)
        
        // 기타 시스템 키워드 제거
        .replace(/^[A-Z_]+:/g, '') // 대문자로 된 시스템 키워드 제거
        .replace(/^[a-z_]+:/g, '') // 소문자로 된 시스템 키워드 제거
        .replace(/^[0-9]+\./g, '') // 숫자로 시작하는 번호 제거
        
        // 특수 문자 번호 제거
        .replace(/^[①②③④⑤⑥⑦⑧⑨⑩]/g, '') // 원문자 번호 제거
        .replace(/^[❶❷❸❹❺❻❼❽❾❿]/g, '') // 원문자 번호 제거
        .replace(/^[⑴⑵⑶⑷⑸⑹⑺⑻⑼⑽]/g, '') // 괄호 숫자 제거
        .replace(/^[㈠㈡㈢㈣㈤㈥㈦㈧㈨㈩]/g, '') // 괄호 한자 제거
        .replace(/^[㉠㉡㉢㉣㉤㉥㉦㉧㉨㉩]/g, '') // 원문자 한자 제거
        .replace(/^[㊀㊁㊂㊃㊄㊅㊆㊇㊈㊉]/g, '') // 원문자 한자 제거
        .replace(/^[㊐㊑㊒㊓㊔㊕㊖㊗㊘㊙]/g, '') // 원문자 한자 제거
        .replace(/^[㊚㊛㊜㊝㊞㊟㊠㊡㊢㊣]/g, '') // 원문자 한자 제거
        .replace(/^[㊤㊥㊦㊧㊨㊩㊪㊫㊬㊭]/g, '') // 원문자 한자 제거
        .replace(/^[㊮㊯㊰㊱㊲㊳㊴㊵㊶㊷]/g, '') // 원문자 한자 제거
        .replace(/^[㊸㊹㊺㊻㊼㊽㊾㊿]/g, ''); // 원문자 한자 제거
    
    // 4. 불필요한 공백 정리
    cleanText = cleanText
        .replace(/\s+/g, ' ') // 연속된 공백을 하나로
        .replace(/^\s+|\s+$/g, '') // 앞뒤 공백 제거
        .replace(/^[,\s]+|[,\s]+$/g, '') // 앞뒤 쉼표와 공백 제거
        .replace(/^[.\s]+|[.\s]+$/g, ''); // 앞뒤 점과 공백 제거
    
    // 5. 빈 텍스트 체크
    if (!cleanText || cleanText.trim().length === 0) {
        console.warn('[TTS] 정리 후 텍스트가 비어있음');
        return null;
    }
    
    // 6. 최종 길이 체크 (너무 긴 텍스트는 자르기)
    if (cleanText.length > 500) {
        console.warn('[TTS] 텍스트가 너무 김, 자름:', cleanText.length);
        cleanText = cleanText.substring(0, 500) + '...';
    }
    
    console.log('[TTS] 정리된 텍스트:', cleanText);
    return cleanText;
}

// 호감도 업데이트 함수 (개선된)
function updateLikability(score) {
    // 기존 호감도 (호환성 유지)
    const likabilityScore = document.getElementById('likability-score');
    const likabilityProgress = document.getElementById('likability-progress');
    
    if (likabilityScore) {
        likabilityScore.innerHTML = `${score}<span>%</span>`;
    }
    
    if (likabilityProgress) {
        const circumference = 2 * Math.PI * 54;
        const offset = circumference - (score / 100) * circumference;
        likabilityProgress.style.strokeDasharray = circumference;
        likabilityProgress.style.strokeDashoffset = offset;
    }
    
    // 새로운 개선된 호감도
    const likabilityScoreEnhanced = document.getElementById('likability-score-enhanced');
    const likabilityProgressEnhanced = document.getElementById('likability-progress-enhanced');
    const likabilityStatus = document.getElementById('likability-status');
    
    if (likabilityScoreEnhanced) {
        likabilityScoreEnhanced.innerHTML = `${score}<span class="score-unit">%</span>`;
    }
    
    if (likabilityProgressEnhanced) {
        const circumference = 314; // 2 * Math.PI * 50
        const offset = circumference - (score / 100) * circumference;
        likabilityProgressEnhanced.style.strokeDashoffset = offset;
    }
    
    if (likabilityStatus) {
        let status = '';
        if (score >= 85) status = '매우 높음';
        else if (score >= 70) status = '높음';
        else if (score >= 50) status = '보통';
        else if (score >= 30) status = '낮음';
        else status = '매우 낮음';
        
        likabilityStatus.textContent = status;
    }
    
    // 호감도 요소 업데이트
    updateLikabilityFactors(score);
}

// 호감도 구성 요소 업데이트
function updateLikabilityFactors(totalScore) {
    // 시뮬레이션된 요소별 점수 (실제로는 개별 메트릭에서 계산)
    const expressionScore = Math.max(0, totalScore + (Math.random() - 0.5) * 20);
    const voiceScore = Math.max(0, totalScore + (Math.random() - 0.5) * 15);
    const conversationScore = Math.max(0, totalScore + (Math.random() - 0.5) * 10);
    
    const factorExpression = document.getElementById('factor-expression');
    const factorVoice = document.getElementById('factor-voice');
    const factorConversation = document.getElementById('factor-conversation');
    
    if (factorExpression) factorExpression.textContent = `${Math.round(expressionScore)}%`;
    if (factorVoice) factorVoice.textContent = `${Math.round(voiceScore)}%`;
    if (factorConversation) factorConversation.textContent = `${Math.round(conversationScore)}%`;
}

// 전역 스코프에 함수들 노출
window.sendMessage = sendMessage;
window.cleanTextForTTS = cleanTextForTTS;
window.updateLikability = updateLikability;
window.updateLikabilityFactors = updateLikabilityFactors;

// getAiResponse 함수 제거됨 - 서버에서 처리


// --- 입력 모드 관리 ---
// voice-input.js에서 통합 관리하므로 제거됨

 // 초기 안내 팝업 닫기 버튼
 const closeGuideBtn = document.getElementById('close-guide-btn');
 if (closeGuideBtn) {
     closeGuideBtn.addEventListener('click', hideInitialGuidePopup);
 }
 
   // 입력 필드 이벤트 (단순화)
  chatInput.addEventListener('input', (e) => {
      // 입력 필드 변경 감지 (필요시 추가 로직)
  });

// 전송 버튼 클릭 이벤트
inputBtn.addEventListener('click', () => {
    const hasText = chatInput.value.trim().length > 0;
    if (hasText) {
        sendMessage();
    }
});

// Enter 키 이벤트
chatInput.addEventListener('keypress', (e) => { 
    if (e.key === 'Enter') sendMessage(); 
});



// --- AI 피드백 분석 기능 (자동 실행) ---
async function runAiAnalysis() {
    const summaryDiv = document.getElementById('ai-feedback-summary');
    if (chatHistory.length < 2) {
        summaryDiv.innerHTML = `
            <div style="font-weight: 600; margin-bottom: 8px;">🍯 실시간 꿀팁!</div>
            <p style="font-size: 13px; line-height: 1.6;">AI와 대화를 2회 이상 나누면<br>자동으로 분석이 시작됩니다.</p>
        `;
        return;
    }

    summaryDiv.textContent = '분석 중...';
    
    try {
        // 서버의 피드백 분석 API 호출
        const response = await fetch(`${window.serverUrl || 'https://dys-phi.vercel.app/api/gke'}/api/feedback`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                chatHistory: chatHistory,
                user_id: userId,
                session_id: currentSessionId
            })
        });

        if (response.ok) {
            const feedback = await response.json();
            updateFeedbackUI(feedback);
        } else {
            throw new Error(`피드백 분석 실패: ${response.status}`);
        }

    } catch (error) {
        console.error("Error analyzing conversation:", error);
        summaryDiv.textContent = "분석 중 오류가 발생했습니다. 잠시 후 다시 시도해주세요.";
    }
}

function setCircleProgress(score) {
    const circle = document.getElementById('likability-progress');
    const radius = circle.r.baseVal.value;
    const circumference = 2 * Math.PI * radius;
    const offset = circumference - (score / 100) * circumference;

    circle.style.strokeDasharray = `${circumference} ${circumference}`;
    circle.style.strokeDashoffset = offset;
    
    document.getElementById('likability-score').innerHTML = `${score}<span>%</span>`;
}

function updateFeedbackUI(feedback) {
    setCircleProgress(feedback.likability);
    
    // 대화 주도권 업데이트 (실제 분석 결과 사용)
    if (window.ConversationAnalyzer) {
        const initiativeAnalysis = window.ConversationAnalyzer.getDetailedAnalysis();
        document.getElementById('user-initiative-bar').style.width = `${initiativeAnalysis.userInitiativeScore}%`;
        document.getElementById('ai-initiative-bar').style.width = `${100 - initiativeAnalysis.userInitiativeScore}%`;
        document.getElementById('initiative-status').textContent = initiativeAnalysis.status;
        document.getElementById('initiative-status').style.color = initiativeAnalysis.color;
        
        // 종합 점수 계산기에 대화 주도권 점수 업데이트
        if (window.ComprehensiveScoreCalculator) {
            window.ComprehensiveScoreCalculator.updateConversationScore('initiative', initiativeAnalysis.userInitiativeScore);
        }
    } else {
        // 폴백: 서버 피드백 사용
        document.getElementById('user-initiative-bar').style.width = `${feedback.initiative}%`;
        document.getElementById('ai-initiative-bar').style.width = `${100 - feedback.initiative}%`;
        document.getElementById('initiative-status').textContent = '분석 대기 중';
        document.getElementById('initiative-status').style.color = '#6b7280';
        
        // 종합 점수 계산기에 대화 주도권 점수 업데이트
        if (window.ComprehensiveScoreCalculator) {
            window.ComprehensiveScoreCalculator.updateConversationScore('initiative', feedback.initiative);
        }
    }
    
    document.getElementById('expression-text').textContent = feedback.expression;
    document.getElementById('tone-score').textContent = `${feedback.tone}%`;
    document.getElementById('gaze-score').textContent = `${feedback.gaze_stability}%`;
    document.getElementById('concentration-score').textContent = `${feedback.concentration}%`;
    document.getElementById('posture-score').textContent = `${feedback.posture}%`;
    document.getElementById('blinking-score').textContent = `${feedback.blinking}%`;
    
    // 종합 점수 계산기에 각 점수 업데이트
    if (window.ComprehensiveScoreCalculator) {
        // 시각적 점수들
        window.ComprehensiveScoreCalculator.updateVisualScore('expression', feedback.expression_score || 60);
        window.ComprehensiveScoreCalculator.updateVisualScore('gaze_stability', feedback.gaze_stability);
        window.ComprehensiveScoreCalculator.updateVisualScore('posture', feedback.posture);
        window.ComprehensiveScoreCalculator.updateVisualScore('blinking', feedback.blinking);
        
        // 청각적 점수들
        window.ComprehensiveScoreCalculator.updateAuditoryScore('tone', feedback.tone);
        window.ComprehensiveScoreCalculator.updateAuditoryScore('concentration', feedback.concentration);
    }

    document.getElementById('ai-feedback-summary').textContent = feedback.summary;
}

// --- 이벤트 리스너 설정 ---
closeBtn.addEventListener('click', toggleFeedbackPanel);

feedbackToggleBtn.addEventListener('click', () => {
    toggleFeedbackPanel();
    if (feedbackPanel.classList.contains('visible')) {
        runAiAnalysis();
    }
});

// 기존 마이크 버튼 이벤트 리스너 제거 (새로운 inputBtn으로 대체됨)

document.querySelectorAll('.suggestion-tags .tag').forEach(tag => {
    tag.addEventListener('click', () => {
        chatInput.value = `"${tag.textContent}"에 대해 이야기해볼까요?`;
        chatInput.focus();
    });
});

 // --- 비디오 재생 관리 ---
 function initializeVideo() {
     const video = document.getElementById('video');
     const videoLoading = document.getElementById('video-loading');
     
     // 비디오 파일 경로 설정 (캐시 방지를 위한 타임스탬프 추가)
     const timestamp = new Date().getTime();
     const videoPath = `${window.serverUrl || 'https://dys-phi.vercel.app/api/gke'}/dys_studio/video/woman1_cafe.mp4?t=${timestamp}`;
     
     console.log('🎬 [VIDEO] 비디오 초기화 시작:', videoPath);
     
     // 로딩 화면 표시
     videoLoading.classList.remove('hidden');
    
    // 비디오 이벤트 리스너 설정
    video.addEventListener('loadstart', () => {
        console.log('🎬 [VIDEO] 비디오 로딩 시작');
    });
    
         video.addEventListener('canplay', () => {
         console.log('✅ [VIDEO] 비디오 재생 준비 완료');
         // 로딩 화면 숨기기
         videoLoading.classList.add('hidden');
         // 자동 재생 시도 (사용자 상호작용 후에만 성공)
         video.play().catch(error => {
             console.log('ℹ️ [VIDEO] 자동 재생 대기 중 (사용자 상호작용 필요)');
             // 사용자 상호작용 시 재생 시작을 위한 이벤트 리스너 추가
             const startPlayback = () => {
                 video.play().then(() => {
                     console.log('✅ [VIDEO] 사용자 상호작용 후 재생 시작');
                     // 이벤트 리스너 제거
                     document.removeEventListener('click', startPlayback);
                     document.removeEventListener('keydown', startPlayback);
                 }).catch(err => {
                     console.error('❌ [VIDEO] 재생 실패:', err);
                 });
             };
             document.addEventListener('click', startPlayback, { once: true });
             document.addEventListener('keydown', startPlayback, { once: true });
         });
     });
     
     video.addEventListener('loadeddata', () => {
         console.log('✅ [VIDEO] 비디오 데이터 로드 완료');
     });
    
    video.addEventListener('ended', () => {
        console.log('🔄 [VIDEO] 비디오 재생 완료, 반복 재생');
        // loop 속성이 있지만 확실히 하기 위해 다시 재생
        video.currentTime = 0;
        video.play().catch(error => {
            console.error('❌ [VIDEO] 반복 재생 실패:', error);
        });
    });
    
    video.addEventListener('error', (error) => {
        console.error('❌ [VIDEO] 비디오 로딩 오류:', error);
        console.error('❌ [VIDEO] 비디오 오류 코드:', video.error?.code);
        console.error('❌ [VIDEO] 비디오 오류 메시지:', video.error?.message);
        console.error('❌ [VIDEO] 비디오 소스:', video.src);
        videoLoading.innerHTML = `
            <div style="text-align: center;">
                <p style="color: #e74c3c; margin-bottom: 8px;">비디오 로딩 실패</p>
                <p style="color: #666; font-size: 12px; margin-bottom: 8px;">오류 코드: ${video.error?.code || 'unknown'}</p>
                <button onclick="initializeVideo()" style="padding: 8px 16px; background: var(--brand2); color: white; border: none; border-radius: 8px; cursor: pointer;">다시 시도</button>
            </div>
        `;
    });
    
         // 비디오 소스 설정 (캐시 방지를 위한 타임스탬프 추가)
     const cacheBuster = new Date().getTime();
     video.src = `${videoPath}?t=${cacheBuster}`;
     video.load();
}

// --- MongoDB 세션 관리 ---
async function createSession() {
    try {
        const sessionName = personaName ? `${personaName}와의 데이트` : '새로운 데이트';
        const response = await fetch(`${window.serverUrl || 'https://dys-phi.vercel.app/api/gke'}/api/chat/sessions`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                session_name: sessionName,
                user_id: userId,
                email: email,
                persona_name: personaName,
                persona_age: personaAge,
                persona_mbti: personaMbti,
                persona_job: personaJob,
                persona_personality: personaPersonality,
                persona_image: personaImage
            })
        });

        if (response.ok) {
            const result = await response.json();
            currentSessionId = result.session_id;
            console.log('✅ [CHAT] 세션 생성 성공:', currentSessionId);
            return true;
        } else {
            console.error('❌ [CHAT] 세션 생성 실패:', response.status);
            return false;
        }
    } catch (error) {
        console.error('❌ [CHAT] 세션 생성 오류:', error);
        return false;
    }
}

// saveMessageToMongoDB 함수 제거됨 - 서버에서 통합 처리

   // --- 카메라 경고 함수들 ---
function showCameraWarning() {
    console.log('[CAMERA] 카메라 경고 표시');
    const warning = document.getElementById('camera-warning');
    if (warning) {
        warning.classList.remove('hidden');
    }
}

function hideCameraWarning() {
    console.log('[CAMERA] 카메라 경고 숨김');
    const warning = document.getElementById('camera-warning');
    if (warning) {
        warning.classList.add('hidden');
    }
}

function showCameraToast() {
    console.log('[CAMERA] 카메라 토스트 경고 표시');
    const toast = document.getElementById('camera-toast');
    if (toast) {
        toast.classList.remove('hidden');
    }
}

function hideCameraToast() {
    console.log('[CAMERA] 카메라 토스트 경고 숨김');
    const toast = document.getElementById('camera-toast');
    if (toast) {
        toast.classList.add('hidden');
    }
}

// --- 카메라 상태 확인 함수 ---
  async function checkCameraStatus() {
      try {
          const stream = await navigator.mediaDevices.getUserMedia({ video: true });
          // 카메라가 정상적으로 작동하면 스트림 정리
          stream.getTracks().forEach(track => track.stop());
          hideCameraWarning();
          hideCameraToast();
          return true;
      } catch (err) {
          console.error("카메라 상태 확인 실패:", err);
          // 토스트 스타일 경고 메시지 표시 (더 깔끔함)
          showCameraToast();
          return false;
      }
  }

// --- 카메라 및 음성 권한 요청 함수 ---
async function requestCameraAndAudioPermissions() {
    console.log('🎤 [PERMISSIONS] 카메라 및 음성 권한 요청 시작');
    
    try {
        // 카메라와 음성 권한을 동시에 요청
        const stream = await navigator.mediaDevices.getUserMedia({ 
            video: true, 
            audio: true 
        });
        
        console.log('✅ [PERMISSIONS] 카메라 및 음성 권한 획득 성공');
        
        // 스트림 정리
        stream.getTracks().forEach(track => {
            track.stop();
            console.log(`🛑 [PERMISSIONS] ${track.kind} 트랙 정리 완료`);
        });
        
        // 권한 상태 저장
        sessionStorage.setItem('permissionsGranted', 'true');
        
        // 경고 메시지 숨기기
        hideCameraWarning();
        hideCameraToast();
        
        return true;
        
    } catch (err) {
        console.error('❌ [PERMISSIONS] 권한 요청 실패:', err);
        
        // 권한 거부 상태 저장
        sessionStorage.setItem('permissionsGranted', 'false');
        
        // 에러 타입에 따른 처리
        if (err.name === 'NotAllowedError') {
            console.warn('⚠️ [PERMISSIONS] 사용자가 권한을 거부했습니다');
            showPermissionDeniedMessage();
        } else if (err.name === 'NotFoundError') {
            console.warn('⚠️ [PERMISSIONS] 카메라 또는 마이크를 찾을 수 없습니다');
            showDeviceNotFoundMessage();
        } else {
            console.warn('⚠️ [PERMISSIONS] 기타 권한 오류:', err.name);
            showCameraToast();
        }
        
        return false;
    }
}

// --- 권한 거부 메시지 표시 ---
function showPermissionDeniedMessage() {
    const message = document.createElement('div');
    message.id = 'permission-denied-message';
    message.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 20px;
        border-radius: 12px;
        text-align: center;
        z-index: 10000;
        max-width: 400px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    `;
    
    message.innerHTML = `
        <div style="font-size: 24px; margin-bottom: 15px;">🎤</div>
        <h3 style="margin: 0 0 10px; color: #ff6b6b;">권한이 필요합니다</h3>
        <p style="margin: 0 0 15px; line-height: 1.5;">
            데이트 시뮬레이션을 위해<br>
            <strong>카메라와 마이크 권한</strong>이 필요합니다.
        </p>
        <p style="margin: 0 0 20px; font-size: 14px; opacity: 0.8;">
            브라우저 설정에서 권한을 허용해주세요.
        </p>
        <button onclick="retryPermissions()" style="
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
        ">다시 시도</button>
        <button onclick="closePermissionMessage()" style="
            background: #666;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            margin-left: 10px;
        ">나중에</button>
    `;
    
    document.body.appendChild(message);
}

// --- 디바이스 없음 메시지 표시 ---
function showDeviceNotFoundMessage() {
    const message = document.createElement('div');
    message.id = 'device-not-found-message';
    message.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 20px;
        border-radius: 12px;
        text-align: center;
        z-index: 10000;
        max-width: 400px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    `;
    
    message.innerHTML = `
        <div style="font-size: 24px; margin-bottom: 15px;">📹</div>
        <h3 style="margin: 0 0 10px; color: #ff6b6b;">디바이스를 찾을 수 없습니다</h3>
        <p style="margin: 0 0 15px; line-height: 1.5;">
            카메라 또는 마이크가<br>
            연결되지 않았습니다.
        </p>
        <p style="margin: 0 0 20px; font-size: 14px; opacity: 0.8;">
            디바이스를 연결하고 다시 시도해주세요.
        </p>
        <button onclick="retryPermissions()" style="
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
        ">다시 시도</button>
        <button onclick="closePermissionMessage()" style="
            background: #666;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            margin-left: 10px;
        ">나중에</button>
    `;
    
    document.body.appendChild(message);
}

// --- 권한 재시도 함수 ---
async function retryPermissions() {
    console.log('🔄 [PERMISSIONS] 권한 재시도 시작');
    
    // 기존 메시지 제거
    closePermissionMessage();
    
    // 잠시 대기 후 권한 재요청
    setTimeout(async () => {
        const success = await requestCameraAndAudioPermissions();
        if (success) {
            console.log('✅ [PERMISSIONS] 권한 재시도 성공');
        }
    }, 500);
}

// --- 권한 메시지 닫기 함수 ---
function closePermissionMessage() {
    const permissionMessage = document.getElementById('permission-denied-message');
    const deviceMessage = document.getElementById('device-not-found-message');
    
    if (permissionMessage) {
        permissionMessage.remove();
    }
    if (deviceMessage) {
        deviceMessage.remove();
    }
}

// --- 권한 상태 확인 함수 ---
async function checkPermissionStatus() {
    try {
        // 권한 상태 확인
        const permissions = await navigator.permissions.query({ name: 'camera' });
        const audioPermissions = await navigator.permissions.query({ name: 'microphone' });
        
        console.log('🔍 [PERMISSIONS] 권한 상태 확인:', {
            camera: permissions.state,
            microphone: audioPermissions.state
        });
        
        return {
            camera: permissions.state,
            microphone: audioPermissions.state,
            allGranted: permissions.state === 'granted' && audioPermissions.state === 'granted'
        };
    } catch (err) {
        console.warn('⚠️ [PERMISSIONS] 권한 상태 확인 실패:', err);
        return {
            camera: 'unknown',
            microphone: 'unknown',
            allGranted: false
        };
    }
}
 
 // --- 앱 초기화 ---
 async function initializeApp() {
     // MongoDB 세션 생성
     const sessionCreated = await createSession();
     if (!sessionCreated) {
         console.error('❌ [CHAT] 세션 생성에 실패했습니다.');
     }
     
     // 권한 상태 확인 및 필요시 요청
     console.log('🎤 [APP] 권한 상태 확인 시작');
     const permissionStatus = await checkPermissionStatus();
     
     if (permissionStatus.allGranted) {
         console.log('✅ [APP] 이미 모든 권한이 허용됨');
         sessionStorage.setItem('permissionsGranted', 'true');
     } else {
         console.log('🔄 [APP] 권한 요청 필요:', permissionStatus);
         const permissionsGranted = await requestCameraAndAudioPermissions();
         
         if (permissionsGranted) {
             console.log('✅ [APP] 권한 획득 완료 - 앱 초기화 계속');
         } else {
             console.warn('⚠️ [APP] 권한 획득 실패 - 제한된 기능으로 계속');
         }
     }
     
     // 카메라 상태 확인 (권한 요청 후)
     await checkCameraStatus();
     
     // 비디오 초기화
     initializeVideo();
     
     // 카메라 분석기 시작
     if (typeof scheduleAnalyzerStart === 'function') {
         console.log('[ANALYZER] 카메라 분석기 시작');
         scheduleAnalyzerStart();
     } else {
         console.warn('[ANALYZER] scheduleAnalyzerStart 함수를 찾을 수 없습니다');
     }
     
     // Persona 정보 카드 추가
     addPersonaCard();
     
          // 초기 안내 팝업 표시
      showInitialGuidePopup();
     
     // WebSocket 연결
     const userData = getUserData();
     if (userData?.token && typeof connectWS === 'function') {
         connectWS(userData.token);
         
         // WebSocket 연결 후 워커 초기화
         setTimeout(() => {
             if (typeof setupLandmarkWorker === 'function') {
                 console.log('[WORKER] 랜드마크 워커 초기화 시작');
                 
                 // 비디오 엘리먼트 가져오기
                 const videoElement = document.getElementById('video');
                 if (videoElement) {
                     setupLandmarkWorker(
                         videoElement,
                         onLandmarkFrame,
                         () => window.suggestedHz || 10
                     );
                     console.log('[WORKER] 랜드마크 워커 초기화 완료');
                 } else {
                     console.error('[WORKER] 비디오 엘리먼트를 찾을 수 없습니다');
                 }
             } else {
                 console.warn('[WORKER] setupLandmarkWorker 함수를 찾을 수 없습니다');
             }
         }, 1000); // 1초 후 워커 초기화
     }
    
         // 액션 버튼 이벤트 리스너 추가
     const recalibrateBtn = document.getElementById('recalibrate-btn');
     if (recalibrateBtn) {
         recalibrateBtn.addEventListener('click', async () => {
             try {
                 // 카메라 권한 확인
                 await navigator.mediaDevices.getUserMedia({ video: true });
                 // 카메라 경고 숨기기
                 hideCameraWarning();
                 // 캘리브레이션 팝업 다시 표시
                 const calibrationOverlay = document.getElementById('calibration-overlay');
                 const mainContent = document.getElementById('main-content');
                 if (calibrationOverlay) calibrationOverlay.classList.remove('hidden');
                 if (mainContent) mainContent.classList.remove('visible');
             } catch (err) {
                 console.error("카메라 권한 실패:", err);
                 showCameraWarning();
             }
         });
     }
    
    const endSessionBtn = document.getElementById('end-session-btn');
    if (endSessionBtn) {
        endSessionBtn.addEventListener('click', () => {
            // 확인 팝업 표시
            showConfirmDialog();
        });
    }
    
    // 확인 팝업 버튼 이벤트 리스너
    const cancelEndBtn = document.getElementById('cancel-end-btn');
    if (cancelEndBtn) {
        cancelEndBtn.addEventListener('click', () => {
            hideConfirmDialog();
        });
    }
    
    const confirmEndBtn = document.getElementById('confirm-end-btn');
    if (confirmEndBtn) {
        confirmEndBtn.addEventListener('click', async () => {
        // 데이트 세션 종료 - 즉시 페이지 이동
        hideConfirmDialog();
        
        // 로딩 상태 표시
        const endBtn = document.getElementById('confirm-end-btn');
        const originalText = endBtn.textContent;
        endBtn.textContent = '종료 중...';
        endBtn.disabled = true;
        
        try {
            // 카메라 분석기 정리
            if (window.cameraAnalyzer) {
                console.log('🧹 [ANALYZER] 카메라 분석기 정리 시작');
                window.cameraAnalyzer.cleanup();
                window.cameraAnalyzer = null;
            }
            
            // 세션 스토리지 정리
            sessionStorage.removeItem('currentSessionId');
            sessionStorage.removeItem('userData');
            console.log('🧹 [SESSION] 세션 데이터 정리 완료');
            // 최종 피드백 데이터 수집
            const finalFeedback = {
                likability: parseInt(document.getElementById('likability-score').textContent) || 0,
                initiative: parseInt(document.getElementById('user-initiative-bar').style.width) || 0,
                tone: parseInt(document.getElementById('tone-score').textContent) || 0,
                concentration: parseInt(document.getElementById('concentration-score').textContent) || 0,
                gaze_stability: parseInt(document.getElementById('gaze-score').textContent) || 0,
                blinking: parseInt(document.getElementById('blinking-score').textContent) || 0,
                posture: parseInt(document.getElementById('posture-score').textContent) || 0,
                expression: document.getElementById('expression-text').textContent || '분석 없음',
                total_score: parseInt(document.getElementById('total-score').textContent) || 0,
                summary: document.getElementById('ai-feedback-summary').textContent || '분석 없음'
            };
            
            // 세션 스토리지에서 사용자 정보 가져오기
            const userData = getUserData();
            if (!userData) {
                throw new Error('사용자 정보를 찾을 수 없습니다.');
            }
            
            const externalUrl = 'https://dys-phi.vercel.app/persona';
 			
 			// 백엔드 API 호출 (백그라운드에서 처리, 응답 대기하지 않음)
 			fetch(`${serverUrl}/api/session/end`, {
 				method: 'POST',
 				headers: {
 					'Content-Type': 'application/json',
 					'Authorization': `Bearer ${userData.token || ''}`
 				},
 				body: JSON.stringify({
 					session_id: currentSessionId,
 					user_id: userData.user_id,
 					email: userData.email,
 					token: userData.token,
 					end_reason: 'user_request',
 					final_feedback: finalFeedback
 				})
 			}).then(response => {
 				if (response.ok) {
 					console.log('✅ [SESSION] 백그라운드 세션 종료 성공');
 				} else {
 					console.warn('⚠️ [SESSION] 백그라운드 세션 종료 실패:', response.status);
 				}
 			}).catch(error => {
 				console.warn('⚠️ [SESSION] 백그라운드 세션 종료 오류:', error);
 			});
 			
 			// 즉시 외부 페이지로 이동 (히스토리에 남기지 않음)
 			console.log('🚀 [SESSION] 즉시 페이지 이동:', externalUrl);
 			window.location.replace(externalUrl);
 			
 		} catch (error) {
 			console.error('❌ [SESSION] 세션 종료 준비 실패:', error);
 			
 			// 에러 발생 시에도 외부 페이지로 이동
 			window.location.replace('https://dys-phi.vercel.app/persona');
 		} finally {
 			// 버튼 상태 복원 (페이지 이동 전에 실행될 수 있음)
 			setTimeout(() => {
 				const endBtn = document.getElementById('confirm-end-btn');
 				if (endBtn) {
 					endBtn.textContent = '예';
 					endBtn.disabled = false;
 				}
 			}, 100);
 		}
 	    });
    
    // 페이지 언로드 시 정리
    window.addEventListener('beforeunload', () => {
        console.log('🧹 [CLEANUP] 페이지 언로드 시 정리 시작');
        cleanupGlobalVariables();
    });
    
    // 페이지 숨김 시 정리
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            console.log('🧹 [CLEANUP] 페이지 숨김 시 정리');
            cleanupGlobalVariables();
        }
    });
}

// --- 전역 변수 정리 함수 ---
function cleanupGlobalVariables() {
    // 워커 관리 시스템 정리
    if (typeof cleanupWorker === 'function') {
        cleanupWorker();
    }
    

    
    // 분석기 정리
    if (window.analyzerClient) {
        try {
            window.analyzerClient.cleanup();
            window.analyzerClient = null;
        } catch (e) {
            console.warn('[CLEANUP] 분석기 정리 실패:', e);
        }
    }
    
    // TTS 관리자 정리
    if (window.ttsManager) {
        try {
            window.ttsManager.cleanup();
            window.ttsManager = null;
        } catch (e) {
            console.warn('[CLEANUP] TTS 정리 실패:', e);
        }
    }
    
    // UI 업데이트 타이머 정리
    if (window.__UI_UPDATE_TIMER__) {
        clearTimeout(window.__UI_UPDATE_TIMER__);
        window.__UI_UPDATE_TIMER__ = null;
    }
    
    // 애니메이션 프레임 정리
    if (window.__PUMP_ANIMATION_ID__) {
        cancelAnimationFrame(window.__PUMP_ANIMATION_ID__);
        window.__PUMP_ANIMATION_ID__ = null;
    }
    
    // 랜드마크 펌프 중지
    __lmPumpStop = true;
    
    console.log('[CLEANUP] 전역 변수 정리 완료');
}

// WebSocket 연결은 initializeApp()에서 처리됨

// 전역 스코프에 권한 관련 함수 노출
window.requestCameraAndAudioPermissions = requestCameraAndAudioPermissions;
window.retryPermissions = retryPermissions;
window.closePermissionMessage = closePermissionMessage;
window.checkPermissionStatus = checkPermissionStatus;
}

// 깜빡임 통계 관리 (mediapipe-direct.js에서 처리됨)
// blinkHistory, lastBlinkTime 등은 mediapipe-direct.js에서 관리됩니다.

// 미소 통계 관리 (개선된 버전)
let smileHistory = []; // 미소 히스토리 (안정화용)
let personalBaseSmile = 50; // 개인별 기준 미소 강도 (동적 계산)
const SMILE_HISTORY_SIZE = 20; // 최근 20개 미소 값으로 기준 계산
const SMILE_SMOOTHING_WINDOW = 5000; // 5초 윈도우로 미소 안정화

// 자세 통계 관리 (안정화용)
let postureHistory = []; // 자세 히스토리 (안정화용)
let smoothedPostureScore = 60; // 안정화된 자세 점수
const POSTURE_HISTORY_SIZE = 15; // 최근 15개 자세 값으로 안정화
const POSTURE_SMOOTHING_WINDOW = 8000; // 8초 윈도우로 자세 안정화
const POSTURE_CHANGE_THRESHOLD = 15; // 급격한 변화 임계값 (15점 이상 변화 시 제한)

// 워커로부터 받은 랜드마크를 배치에 적재 (개선된 버전)
function onLandmarkFrame(lmBuffer, ear) {
  console.log('[LANDMARK] 랜드마크 처리 시작:', { ear });
  
  // Float32Array를 Uint8Array로 변환
  const b = new Uint8Array(lmBuffer);
  let s = "";
  for (let i = 0; i < b.length; i++) s += String.fromCharCode(b[i]);
  const base64 = btoa(s);

  const now = Date.now();

  // 미소 히스토리는 updateCameraMetrics에서 처리됨 (metrics 객체가 있을 때)

  // 자세 히스토리는 updateCameraMetrics에서 처리됨 (metrics 객체가 있을 때)

  // 랜드마크 배치에 추가 (WebSocket 전송용)
  if (!window.lmBatch) {
    // lmBatch가 없으면 초기화
    window.lmBatch = [];
    console.log('[LANDMARK] lmBatch 초기화됨');
  }
  
  window.lmBatch.push({
    t: now,
    model: "facemesh-468",
    mode: "full",
    lm: base64,
    ear
  });
  
  console.log('[LANDMARK] 배치에 추가됨:', window.lmBatch.length, '개 프레임');
}

// 깜빡임 계산 함수들은 mediapipe-direct.js에서 처리됩니다.
// calculateShortBlinkRate, calculateBlinkRate 등은 mediapipe-direct.js에서 관리됩니다.

// --- 팝업 관리자 모듈에서 처리됨 ---
// 팝업 관련 함수들은 js/popup-manager.js에서 관리됩니다.

// --- 시선 안정성 상세 정보 팝업 함수들 ---
function showGazeDetails() {
    const popup = document.getElementById('gaze-details-popup');
    if (popup) {
        popup.classList.add('active');
        updateGazePopupContent();
    }
}

function closeGazeDetails() {
    const popup = document.getElementById('gaze-details-popup');
    if (popup) {
        popup.classList.remove('active');
    }
}

function updateGazePopupContent() {
    if (!currentGazeData) {
        document.getElementById('gaze-main-value').textContent = '데이터 없음';
        document.getElementById('gaze-stability-value').textContent = '0%';
        document.getElementById('gaze-landmarks').innerHTML = '<div class="no-data">시선 분석 데이터가 없습니다.</div>';
        document.getElementById('gaze-criteria-text').innerHTML = '시선 분석 데이터가 없습니다.';
        document.getElementById('gaze-explanation-text').innerHTML = '시선 분석 데이터가 없습니다.';
        return;
    }
    
    // 주요 정보 업데이트
    const isFocused = currentGazeData.isFocused;
    document.getElementById('gaze-main-value').textContent = isFocused ? '집중 중' : '분산됨';
    document.getElementById('gaze-stability-value').textContent = `${currentGazeData.score}%`;
    
    // 랜드마크 정보 업데이트
    updateGazeLandmarksInfo();
    
    // 평가 기준 업데이트
    updateGazeCriteriaInfo();
    
    // 점수 계산 근거 업데이트
    updateGazeExplanationInfo();
}

function updateGazeLandmarksInfo() {
    const landmarksDiv = document.getElementById('gaze-landmarks');
    
    // 시선 분석에만 사용되는 MediaPipe FaceMesh 랜드마크 정보
    const landmarkInfo = [
        { name: '왼쪽 눈 윤곽', value: '16개', description: '왼쪽 눈의 윤곽선을 구성하는 랜드마크' },
        { name: '오른쪽 눈 윤곽', value: '16개', description: '오른쪽 눈의 윤곽선을 구성하는 랜드마크' },
        { name: '왼쪽 눈썹', value: '10개', description: '왼쪽 눈썹의 윤곽선을 구성하는 랜드마크' },
        { name: '오른쪽 눈썹', value: '10개', description: '오른쪽 눈썹의 윤곽선을 구성하는 랜드마크' },
        { name: '눈동자 중심', value: '2개', description: '왼쪽/오른쪽 눈동자의 중심점' },
        { name: '시선 추적용', value: '54개', description: '시선 방향과 안정성 분석에 사용되는 총 랜드마크' }
    ];
    
    let html = '';
    landmarkInfo.forEach(item => {
        html += `
            <div class="landmark-item">
                <div class="landmark-name">${item.name}</div>
                <div class="landmark-value">${item.value}</div>
                <div class="landmark-description">${item.description}</div>
            </div>
        `;
    });
    
    landmarksDiv.innerHTML = html;
}

function updateGazeCriteriaInfo() {
    const criteriaDiv = document.getElementById('gaze-criteria-text');
    
    const criteria = `
        <div class="criteria-section">
            <h4>🎯 시선 안정성 평가 기준</h4>
            <ul>
                <li><strong>점프 거리 (40%)</strong>: 눈동자 중심점의 급격한 이동 거리</li>
                <li><strong>속도 (30%)</strong>: 눈동자 이동의 평균 속도 (픽셀/프레임)</li>
                <li><strong>안정성 (30%)</strong>: 눈동자가 한 영역에 머무는 정도</li>
            </ul>
            
            <h4>👁️ 시선 분석 방법</h4>
            <ul>
                <li><strong>눈 윤곽 추적</strong>: 32개 랜드마크로 눈의 위치와 크기 측정</li>
                <li><strong>눈동자 중심 계산</strong>: 눈 윤곽 내부의 중심점 추정</li>
                <li><strong>시선 방향 분석</strong>: 눈동자 중심의 화면 내 위치 변화 추적</li>
                <li><strong>안정성 판단</strong>: 일정 시간 동안의 시선 변화량 계산</li>
            </ul>
            
            <h4>📊 점수 기준</h4>
            <ul>
                <li><strong>90-100점</strong>: 매우 안정적인 시선 (집중력 우수)</li>
                <li><strong>70-89점</strong>: 안정적인 시선 (적절한 집중)</li>
                <li><strong>50-69점</strong>: 보통 수준의 시선 (일반적인 상태)</li>
                <li><strong>30-49점</strong>: 불안정한 시선 (집중력 저하)</li>
                <li><strong>0-29점</strong>: 매우 불안정한 시선 (심각한 집중력 문제)</li>
            </ul>
        </div>
    `;
    
    criteriaDiv.innerHTML = criteria;
}

function updateGazeExplanationInfo() {
    const explanationDiv = document.getElementById('gaze-explanation-text');
    
    if (!currentGazeData) {
        explanationDiv.innerHTML = '시선 분석 데이터가 없습니다.';
        return;
    }
    
    const { jumpDistance, velocity, isFocused, score } = currentGazeData;
    
    let explanation = `<div class="explanation-section">`;
    explanation += `<h4>📈 현재 분석 결과</h4>`;
    explanation += `<ul>`;
    explanation += `<li><strong>시선 상태</strong>: ${isFocused ? '집중 중' : '분산됨'}</li>`;
    explanation += `<li><strong>점프 거리</strong>: ${(jumpDistance * 100).toFixed(2)}% (화면 대비)</li>`;
    explanation += `<li><strong>이동 속도</strong>: ${velocity.toFixed(4)} (픽셀/프레임)</li>`;
    explanation += `<li><strong>최종 점수</strong>: ${score}점</li>`;
    explanation += `</ul>`;
    
    // 점수 해석
    if (score >= 90) {
        explanation += `<p>🎯 <strong>매우 우수한 시선 안정성</strong>: 시선이 매우 안정적으로 유지되고 있습니다.</p>`;
    } else if (score >= 70) {
        explanation += `<p>🎯 <strong>우수한 시선 안정성</strong>: 시선이 안정적으로 유지되고 있습니다.</p>`;
    } else if (score >= 50) {
        explanation += `<p>🎯 <strong>보통 수준의 시선 안정성</strong>: 시선이 어느 정도 안정적입니다.</p>`;
    } else if (score >= 30) {
        explanation += `<p>🎯 <strong>개선이 필요한 시선 안정성</strong>: 시선이 다소 불안정합니다.</p>`;
    } else {
        explanation += `<p>🎯 <strong>매우 개선이 필요한 시선 안정성</strong>: 시선이 매우 불안정합니다.</p>`;
    }
    
    explanation += `</div>`;
    
    explanationDiv.innerHTML = explanation;
}

// --- 집중도 상세 정보 팝업 함수들 ---
function showConcentrationDetails() {
    const popup = document.getElementById('concentration-details-popup');
    if (popup) {
        popup.classList.add('active');
        updateConcentrationPopupContent();
    }
}

function closeConcentrationDetails() {
    const popup = document.getElementById('concentration-details-popup');
    if (popup) {
        popup.classList.remove('active');
    }
}

function updateConcentrationPopupContent() {
    if (!currentConcentrationData) {
        document.getElementById('concentration-main-value').textContent = '데이터 없음';
        document.getElementById('concentration-score-value').textContent = '0%';
        document.getElementById('concentration-factors').innerHTML = '<div class="no-data">집중도 분석 데이터가 없습니다.</div>';
        document.getElementById('concentration-criteria-text').innerHTML = '집중도 분석 데이터가 없습니다.';
        document.getElementById('concentration-explanation-text').innerHTML = '집중도 분석 데이터가 없습니다.';
        return;
    }
    
    // 주요 정보 업데이트
    const isFocused = currentConcentrationData.isFocused;
    document.getElementById('concentration-main-value').textContent = isFocused ? '집중 중' : '분산됨';
    document.getElementById('concentration-score-value').textContent = `${currentConcentrationData.score}%`;
    
    // 분석 요소 업데이트
    updateConcentrationFactorsInfo();
    
    // 평가 기준 업데이트
    updateConcentrationCriteriaInfo();
    
    // 점수 계산 근거 업데이트
    updateConcentrationExplanationInfo();
}

function updateConcentrationFactorsInfo() {
    const factorsDiv = document.getElementById('concentration-factors');
    
    // 집중도 분석에 사용되는 요소들
    const factorInfo = [
        { name: '시선 안정성', value: '35%', description: '시선이 한 곳에 머무는 정도' },
        { name: '시선 집중도', value: '35%', description: '시선이 화면 중앙에 집중되는 정도' },
        { name: '표정 따뜻함', value: '30%', description: '긍정적인 표정으로 집중력 표현' },
        { name: '눈동자 추적', value: '실시간', description: '눈동자 움직임으로 집중 상태 판단' },
        { name: '시선 이탈 시간', value: '2초 이내', description: '시선이 화면을 벗어나는 시간' },
        { name: '집중 지속성', value: '연속성', description: '지속적인 집중 상태 유지' }
    ];
    
    let html = '';
    factorInfo.forEach(item => {
        html += `
            <div class="factor-item">
                <div class="factor-name">${item.name}</div>
                <div class="factor-value">${item.value}</div>
                <div class="factor-description">${item.description}</div>
            </div>
        `;
    });
    
    factorsDiv.innerHTML = html;
}

function updateConcentrationCriteriaInfo() {
    const criteriaDiv = document.getElementById('concentration-criteria-text');
    
    const criteria = `
        <div class="criteria-section">
            <h4>🎯 집중도 평가 기준</h4>
            <ul>
                <li><strong>시선 안정성 (35%)</strong>: 시선이 한 곳에 머무는 정도</li>
                <li><strong>시선 집중도 (35%)</strong>: 시선이 화면 중앙에 집중되는 정도</li>
                <li><strong>표정 따뜻함 (30%)</strong>: 긍정적인 표정으로 집중력 표현</li>
            </ul>
            
            <h4>🧠 집중도 분석 방법</h4>
            <ul>
                <li><strong>눈동자 추적</strong>: 32개 랜드마크로 눈동자 위치 추적</li>
                <li><strong>시선 방향 분석</strong>: 화면 중앙 대비 시선 위치 계산</li>
                <li><strong>집중 지속성</strong>: 일정 시간 동안의 집중 상태 유지</li>
                <li><strong>시선 이탈 감지</strong>: 화면을 벗어나는 시선 감지</li>
            </ul>
            
            <h4>📊 점수 기준</h4>
            <ul>
                <li><strong>90-100점</strong>: 매우 높은 집중도 (완벽한 집중)</li>
                <li><strong>70-89점</strong>: 높은 집중도 (좋은 집중)</li>
                <li><strong>50-69점</strong>: 보통 집중도 (일반적인 집중)</li>
                <li><strong>30-49점</strong>: 낮은 집중도 (집중력 저하)</li>
                <li><strong>0-29점</strong>: 매우 낮은 집중도 (심각한 집중력 문제)</li>
            </ul>
        </div>
    `;
    
    criteriaDiv.innerHTML = criteria;
}

function updateConcentrationExplanationInfo() {
    const explanationDiv = document.getElementById('concentration-explanation-text');
    
    if (!currentConcentrationData) {
        explanationDiv.innerHTML = '집중도 분석 데이터가 없습니다.';
        return;
    }
    
    const { jumpDistance, velocity, isFocused, gazeDirection, score } = currentConcentrationData;
    
    let explanation = `<div class="explanation-section">`;
    explanation += `<h4>📈 현재 분석 결과</h4>`;
    explanation += `<ul>`;
    explanation += `<li><strong>집중 상태</strong>: ${isFocused ? '집중 중' : '분산됨'}</li>`;
    explanation += `<li><strong>시선 방향</strong>: ${gazeDirection || '중앙'}</li>`;
    explanation += `<li><strong>점프 거리</strong>: ${(jumpDistance * 100).toFixed(2)}% (화면 대비)</li>`;
    explanation += `<li><strong>이동 속도</strong>: ${velocity.toFixed(4)} (픽셀/프레임)</li>`;
    explanation += `<li><strong>최종 점수</strong>: ${score}점</li>`;
    explanation += `</ul>`;
    
    // 점수 해석
    if (score >= 90) {
        explanation += `<p>🎯 <strong>완벽한 집중도</strong>: 시선이 매우 안정적이고 화면에 완벽하게 집중하고 있습니다.</p>`;
    } else if (score >= 70) {
        explanation += `<p>🎯 <strong>우수한 집중도</strong>: 시선이 안정적이고 화면에 잘 집중하고 있습니다.</p>`;
    } else if (score >= 50) {
        explanation += `<p>🎯 <strong>보통 집중도</strong>: 시선이 어느 정도 안정적이고 적절히 집중하고 있습니다.</p>`;
    } else if (score >= 30) {
        explanation += `<p>🎯 <strong>개선이 필요한 집중도</strong>: 시선이 불안정하고 집중력이 저하되고 있습니다.</p>`;
    } else {
        explanation += `<p>🎯 <strong>매우 개선이 필요한 집중도</strong>: 시선이 매우 불안정하고 심각한 집중력 문제가 있습니다.</p>`;
    }
    
    explanation += `</div>`;
    
    explanationDiv.innerHTML = explanation;
}

// 팝업 외부 클릭 시 닫기
document.addEventListener('click', function(event) {
    const expressionPopup = document.getElementById('expression-details-popup');
    const gazePopup = document.getElementById('gaze-details-popup');
    const concentrationPopup = document.getElementById('concentration-details-popup');
    
    if (expressionPopup && event.target === expressionPopup) {
        closeExpressionDetails();
    }
    
    if (gazePopup && event.target === gazePopup) {
        closeGazeDetails();
    }
    
    if (concentrationPopup && event.target === concentrationPopup) {
        closeConcentrationDetails();
    }
});

// --- 개인화된 꿀팁 생성 ---
function generatePersonalizedTips(metrics) {
  const tips = [];
  
  // 자세 관련 (실제 UI 점수 사용)
  const postureElement = document.getElementById('posture-score');
  const postureScore = postureElement ? parseInt(postureElement.textContent) : 60;
  
  if (postureScore < 70) {
    if (postureScore < 50) {
      tips.push("자세가 많이 나빠졌어요. 목을 곧게 펴고 어깨를 내려보세요.");
    } else {
      tips.push("자세를 조금 더 개선해보세요. 목을 곧게 펴고 어깨를 내려보세요.");
    }
  }
  
  // 어깨 자세 관련
  if (metrics?.shoulderAnalysis) {
    const shoulder = metrics.shoulderAnalysis;
    
    // details가 있는지 확인 후 접근
    if (shoulder.details && shoulder.details.heightBalance < 70) {
      tips.push("어깨 높이를 맞춰 균형잡힌 자세를 유지하세요.");
    }
    
    if (shoulder.details && shoulder.details.slope < 70) {
      tips.push("어깨를 수평으로 맞춰 삐딱한 자세를 교정하세요.");
    }
    
    if (shoulder.details && shoulder.details.width < 70) {
      tips.push("어깨를 자연스럽게 펴고 올바른 자세를 취하세요.");
    }
    
    if (shoulder.details && shoulder.details.rotation < 70) {
      tips.push("한쪽 어깨가 앞으로 나오지 않도록 주의하세요.");
    }
    
    // details가 없으면 전체 점수로 판단
    if (!shoulder.details && shoulder.shoulderPostureScore < 70) {
      tips.push("어깨 자세를 개선해보세요.");
    }
  }
  
  // 시선 관련 (실제 UI 점수 사용)
  const gazeElement = document.getElementById('gaze-score');
  const gazeScore = gazeElement ? parseInt(gazeElement.textContent) : 60;
  
  if (gazeScore < 60) {
    tips.push("화면 중앙을 응시하며 집중해보세요.");
  }
  
  // 깜빡임 관련 (실제 UI 점수 사용)
  const blinkElement = document.getElementById('blinking-score');
  const blinkScore = blinkElement ? parseInt(blinkElement.textContent) : 80;
  
  if (blinkScore < 60) {
    tips.push("자연스럽게 깜빡여 눈을 보호하세요.");
  } else if (blinkScore < 80) {
    tips.push("깜빡임이 조금 부족해요. 편안하게 깜빡여보세요.");
  }
  
  // 미소 관련 (개인별 기준 적용)
  if (metrics?.smileIntensity !== undefined && metrics?.personalBaseSmile !== undefined) {
    const smileRatio = metrics.smileIntensity / metrics.personalBaseSmile;
    
    if (smileRatio < 0.7) {
      tips.push("😊 표정이 평소보다 많이 딱딱해 보여요. 입꼬리를 살짝 올려보세요!");
    } else if (smileRatio < 0.9) {
      tips.push("😊 표정이 평소보다 조금 딱딱해 보여요. 자연스러운 미소를 연습해보세요!");
    } else if (smileRatio > 1.3) {
      tips.push("😊 표정이 평소보다 많이 밝아 보여요. 너무 과하지 않게 자연스럽게 유지해보세요!");
    }
  } else if (metrics?.smileIntensity < 30) {
    // 개인별 기준이 없을 때 기존 방식 사용
    tips.push("편안한 미소로 대화를 시작해보세요.");
  }
  
  // 기본 꿀팁 (조건에 맞지 않을 때)
  if (tips.length === 0) {
    tips.push("훌륭한 자세입니다! 계속 유지해보세요.");
  }
  
  return tips.slice(0, 3); // 최대 3개까지만 표시
}

// --- 랜드마크 배치 처리 (제거됨) ---

</script>
</body>
</html>